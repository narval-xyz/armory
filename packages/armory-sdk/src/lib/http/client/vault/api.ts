/* tslint:disable */
/* eslint-disable */
/**
 * Vault
 * Secure storage for private keys and sensitive data, designed to protect your most critical assets in web3.0
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'id': string;
    /**
     * 
     * @type {any}
     * @memberof AccountDto
     */
    'publicKey': any;
    /**
     * 
     * @type {any}
     * @memberof AccountDto
     */
    'address': any;
    /**
     * 
     * @type {WalletsDtoWalletsInnerOrigin}
     * @memberof AccountDto
     */
    'origin': WalletsDtoWalletsInnerOrigin;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'derivationPath'?: string;
}
/**
 * 
 * @export
 * @interface AccountsDto
 */
export interface AccountsDto {
    /**
     * 
     * @type {Array<WalletDtoAccount>}
     * @memberof AccountsDto
     */
    'accounts': Array<WalletDtoAccount>;
}
/**
 * 
 * @export
 * @interface ClientDto
 */
export interface ClientDto {
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'clientId': string;
    /**
     * 
     * @type {CreateClientDtoEngineJwk}
     * @memberof ClientDto
     */
    'engineJwk'?: CreateClientDtoEngineJwk;
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'audience'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'issuer'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientDto
     */
    'maxTokenAge'?: number;
    /**
     * 
     * @type {EncryptionKeyDtoPublicKey}
     * @memberof ClientDto
     */
    'backupPublicKey'?: EncryptionKeyDtoPublicKey;
    /**
     * 
     * @type {boolean}
     * @memberof ClientDto
     */
    'allowKeyExport'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientDto
     */
    'allowWildcard'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'baseUrl'?: string;
    /**
     * 
     * @type {any}
     * @memberof ClientDto
     */
    'createdAt': any;
    /**
     * 
     * @type {any}
     * @memberof ClientDto
     */
    'updatedAt': any;
}
/**
 * 
 * @export
 * @interface CreateClientDto
 */
export interface CreateClientDto {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'clientId'?: string;
    /**
     * 
     * @type {CreateClientDtoEngineJwk}
     * @memberof CreateClientDto
     */
    'engineJwk'?: CreateClientDtoEngineJwk;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'audience'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'issuer'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateClientDto
     */
    'maxTokenAge'?: number;
    /**
     * 
     * @type {EncryptionKeyDtoPublicKey}
     * @memberof CreateClientDto
     */
    'backupPublicKey'?: EncryptionKeyDtoPublicKey;
    /**
     * 
     * @type {boolean}
     * @memberof CreateClientDto
     */
    'allowKeyExport'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateClientDto
     */
    'allowWildcard'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'baseUrl'?: string;
}
/**
 * @type CreateClientDtoEngineJwk
 * @export
 */
export type CreateClientDtoEngineJwk = CreateClientDtoEngineJwkOneOf | CreateClientDtoEngineJwkOneOf1 | CreateClientDtoEngineJwkOneOf2 | CreateClientDtoEngineJwkOneOf3 | EncryptionKeyDtoPublicKey;

/**
 * 
 * @export
 * @interface CreateClientDtoEngineJwkOneOf
 */
export interface CreateClientDtoEngineJwkOneOf {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'kty': CreateClientDtoEngineJwkOneOfKtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'alg': CreateClientDtoEngineJwkOneOfAlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'use'?: CreateClientDtoEngineJwkOneOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'crv': CreateClientDtoEngineJwkOneOfCrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'x': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'y': string;
}

export const CreateClientDtoEngineJwkOneOfKtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoEngineJwkOneOfKtyEnum = typeof CreateClientDtoEngineJwkOneOfKtyEnum[keyof typeof CreateClientDtoEngineJwkOneOfKtyEnum];
export const CreateClientDtoEngineJwkOneOfAlgEnum = {
    Es256K: 'ES256K'
} as const;

export type CreateClientDtoEngineJwkOneOfAlgEnum = typeof CreateClientDtoEngineJwkOneOfAlgEnum[keyof typeof CreateClientDtoEngineJwkOneOfAlgEnum];
export const CreateClientDtoEngineJwkOneOfUseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoEngineJwkOneOfUseEnum = typeof CreateClientDtoEngineJwkOneOfUseEnum[keyof typeof CreateClientDtoEngineJwkOneOfUseEnum];
export const CreateClientDtoEngineJwkOneOfCrvEnum = {
    Secp256k1: 'secp256k1'
} as const;

export type CreateClientDtoEngineJwkOneOfCrvEnum = typeof CreateClientDtoEngineJwkOneOfCrvEnum[keyof typeof CreateClientDtoEngineJwkOneOfCrvEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoEngineJwkOneOf1
 */
export interface CreateClientDtoEngineJwkOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'kty': CreateClientDtoEngineJwkOneOf1KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'alg': CreateClientDtoEngineJwkOneOf1AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'use'?: CreateClientDtoEngineJwkOneOf1UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'crv': CreateClientDtoEngineJwkOneOf1CrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'x': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'y': string;
}

export const CreateClientDtoEngineJwkOneOf1KtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoEngineJwkOneOf1KtyEnum = typeof CreateClientDtoEngineJwkOneOf1KtyEnum[keyof typeof CreateClientDtoEngineJwkOneOf1KtyEnum];
export const CreateClientDtoEngineJwkOneOf1AlgEnum = {
    Es256: 'ES256'
} as const;

export type CreateClientDtoEngineJwkOneOf1AlgEnum = typeof CreateClientDtoEngineJwkOneOf1AlgEnum[keyof typeof CreateClientDtoEngineJwkOneOf1AlgEnum];
export const CreateClientDtoEngineJwkOneOf1UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoEngineJwkOneOf1UseEnum = typeof CreateClientDtoEngineJwkOneOf1UseEnum[keyof typeof CreateClientDtoEngineJwkOneOf1UseEnum];
export const CreateClientDtoEngineJwkOneOf1CrvEnum = {
    P256: 'P-256'
} as const;

export type CreateClientDtoEngineJwkOneOf1CrvEnum = typeof CreateClientDtoEngineJwkOneOf1CrvEnum[keyof typeof CreateClientDtoEngineJwkOneOf1CrvEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoEngineJwkOneOf2
 */
export interface CreateClientDtoEngineJwkOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'kty': CreateClientDtoEngineJwkOneOf2KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'crv': CreateClientDtoEngineJwkOneOf2CrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'alg': CreateClientDtoEngineJwkOneOf2AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'use'?: CreateClientDtoEngineJwkOneOf2UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'kid': string;
    /**
     * 
     * @type {any}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'addr': any;
}

export const CreateClientDtoEngineJwkOneOf2KtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoEngineJwkOneOf2KtyEnum = typeof CreateClientDtoEngineJwkOneOf2KtyEnum[keyof typeof CreateClientDtoEngineJwkOneOf2KtyEnum];
export const CreateClientDtoEngineJwkOneOf2CrvEnum = {
    Secp256k1: 'secp256k1'
} as const;

export type CreateClientDtoEngineJwkOneOf2CrvEnum = typeof CreateClientDtoEngineJwkOneOf2CrvEnum[keyof typeof CreateClientDtoEngineJwkOneOf2CrvEnum];
export const CreateClientDtoEngineJwkOneOf2AlgEnum = {
    Es256K: 'ES256K'
} as const;

export type CreateClientDtoEngineJwkOneOf2AlgEnum = typeof CreateClientDtoEngineJwkOneOf2AlgEnum[keyof typeof CreateClientDtoEngineJwkOneOf2AlgEnum];
export const CreateClientDtoEngineJwkOneOf2UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoEngineJwkOneOf2UseEnum = typeof CreateClientDtoEngineJwkOneOf2UseEnum[keyof typeof CreateClientDtoEngineJwkOneOf2UseEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoEngineJwkOneOf3
 */
export interface CreateClientDtoEngineJwkOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'kty': CreateClientDtoEngineJwkOneOf3KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'alg': CreateClientDtoEngineJwkOneOf3AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'use'?: CreateClientDtoEngineJwkOneOf3UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'crv': CreateClientDtoEngineJwkOneOf3CrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'x': string;
}

export const CreateClientDtoEngineJwkOneOf3KtyEnum = {
    Okp: 'OKP'
} as const;

export type CreateClientDtoEngineJwkOneOf3KtyEnum = typeof CreateClientDtoEngineJwkOneOf3KtyEnum[keyof typeof CreateClientDtoEngineJwkOneOf3KtyEnum];
export const CreateClientDtoEngineJwkOneOf3AlgEnum = {
    Eddsa: 'EDDSA'
} as const;

export type CreateClientDtoEngineJwkOneOf3AlgEnum = typeof CreateClientDtoEngineJwkOneOf3AlgEnum[keyof typeof CreateClientDtoEngineJwkOneOf3AlgEnum];
export const CreateClientDtoEngineJwkOneOf3UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoEngineJwkOneOf3UseEnum = typeof CreateClientDtoEngineJwkOneOf3UseEnum[keyof typeof CreateClientDtoEngineJwkOneOf3UseEnum];
export const CreateClientDtoEngineJwkOneOf3CrvEnum = {
    Ed25519: 'Ed25519'
} as const;

export type CreateClientDtoEngineJwkOneOf3CrvEnum = typeof CreateClientDtoEngineJwkOneOf3CrvEnum[keyof typeof CreateClientDtoEngineJwkOneOf3CrvEnum];

/**
 * 
 * @export
 * @interface DeriveAccountDto
 */
export interface DeriveAccountDto {
    /**
     * 
     * @type {string}
     * @memberof DeriveAccountDto
     */
    'keyId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeriveAccountDto
     */
    'derivationPaths'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DeriveAccountDto
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface DeriveAccountResponseDto
 */
export interface DeriveAccountResponseDto {
    /**
     * 
     * @type {Array<WalletDtoAccount>}
     * @memberof DeriveAccountResponseDto
     */
    'accounts': Array<WalletDtoAccount>;
}
/**
 * 
 * @export
 * @interface EncryptionKeyDto
 */
export interface EncryptionKeyDto {
    /**
     * 
     * @type {EncryptionKeyDtoPublicKey}
     * @memberof EncryptionKeyDto
     */
    'publicKey': EncryptionKeyDtoPublicKey;
}
/**
 * 
 * @export
 * @interface EncryptionKeyDtoPublicKey
 */
export interface EncryptionKeyDtoPublicKey {
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'kty': EncryptionKeyDtoPublicKeyKtyEnum;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'alg': EncryptionKeyDtoPublicKeyAlgEnum;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'use'?: EncryptionKeyDtoPublicKeyUseEnum;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'n': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'e': string;
}

export const EncryptionKeyDtoPublicKeyKtyEnum = {
    Rsa: 'RSA'
} as const;

export type EncryptionKeyDtoPublicKeyKtyEnum = typeof EncryptionKeyDtoPublicKeyKtyEnum[keyof typeof EncryptionKeyDtoPublicKeyKtyEnum];
export const EncryptionKeyDtoPublicKeyAlgEnum = {
    Rs256: 'RS256'
} as const;

export type EncryptionKeyDtoPublicKeyAlgEnum = typeof EncryptionKeyDtoPublicKeyAlgEnum[keyof typeof EncryptionKeyDtoPublicKeyAlgEnum];
export const EncryptionKeyDtoPublicKeyUseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type EncryptionKeyDtoPublicKeyUseEnum = typeof EncryptionKeyDtoPublicKeyUseEnum[keyof typeof EncryptionKeyDtoPublicKeyUseEnum];

/**
 * 
 * @export
 * @interface GenerateWalletDto
 */
export interface GenerateWalletDto {
    /**
     * 
     * @type {GenerateWalletDtoCurve}
     * @memberof GenerateWalletDto
     */
    'curve'?: GenerateWalletDtoCurve;
    /**
     * 
     * @type {string}
     * @memberof GenerateWalletDto
     */
    'keyId'?: string;
}
/**
 * @type GenerateWalletDtoCurve
 * @export
 */
export type GenerateWalletDtoCurve = string;

/**
 * 
 * @export
 * @interface ImportPrivateKeyDto
 */
export interface ImportPrivateKeyDto {
    /**
     * Account Private Key, unencrypted
     * @type {any}
     * @memberof ImportPrivateKeyDto
     */
    'privateKey'?: any;
    /**
     * Account Private Key encrypted with JWE. Header MUST include \"kid\"
     * @type {string}
     * @memberof ImportPrivateKeyDto
     */
    'encryptedPrivateKey'?: string;
    /**
     * If not provided, it will be derived as \"eip155:eoa:${address}\"
     * @type {string}
     * @memberof ImportPrivateKeyDto
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface ImportWalletDto
 */
export interface ImportWalletDto {
    /**
     * 
     * @type {string}
     * @memberof ImportWalletDto
     */
    'keyId'?: string;
    /**
     * 
     * @type {GenerateWalletDtoCurve}
     * @memberof ImportWalletDto
     */
    'curve'?: GenerateWalletDtoCurve;
    /**
     * 
     * @type {string}
     * @memberof ImportWalletDto
     */
    'encryptedSeed': string;
}
/**
 * 
 * @export
 * @interface PongDto
 */
export interface PongDto {
    /**
     * 
     * @type {boolean}
     * @memberof PongDto
     */
    'pong': boolean;
}
/**
 * 
 * @export
 * @interface SignRequestDto
 */
export interface SignRequestDto {
    /**
     * 
     * @type {SignRequestDtoRequest}
     * @memberof SignRequestDto
     */
    'request': SignRequestDtoRequest;
}
/**
 * @type SignRequestDtoRequest
 * @export
 */
export type SignRequestDtoRequest = SignRequestDtoRequestOneOf | SignRequestDtoRequestOneOf1 | SignRequestDtoRequestOneOf2 | SignRequestDtoRequestOneOf3 | SignRequestDtoRequestOneOf4;

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf
 */
export interface SignRequestDtoRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'action': SignRequestDtoRequestOneOfActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOfTransactionRequest}
     * @memberof SignRequestDtoRequestOneOf
     */
    'transactionRequest': SignRequestDtoRequestOneOfTransactionRequest;
}

export const SignRequestDtoRequestOneOfActionEnum = {
    SignTransaction: 'signTransaction'
} as const;

export type SignRequestDtoRequestOneOfActionEnum = typeof SignRequestDtoRequestOneOfActionEnum[keyof typeof SignRequestDtoRequestOneOfActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf1
 */
export interface SignRequestDtoRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'action': SignRequestDtoRequestOneOf1ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOf1Message}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'message': SignRequestDtoRequestOneOf1Message;
}

export const SignRequestDtoRequestOneOf1ActionEnum = {
    SignMessage: 'signMessage'
} as const;

export type SignRequestDtoRequestOneOf1ActionEnum = typeof SignRequestDtoRequestOneOf1ActionEnum[keyof typeof SignRequestDtoRequestOneOf1ActionEnum];

/**
 * @type SignRequestDtoRequestOneOf1Message
 * @export
 */
export type SignRequestDtoRequestOneOf1Message = SignRequestDtoRequestOneOf1MessageOneOf | string;

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf1MessageOneOf
 */
export interface SignRequestDtoRequestOneOf1MessageOneOf {
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf1MessageOneOf
     */
    'raw': any;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2
 */
export interface SignRequestDtoRequestOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'action': SignRequestDtoRequestOneOf2ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOf2TypedData}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'typedData': SignRequestDtoRequestOneOf2TypedData;
}

export const SignRequestDtoRequestOneOf2ActionEnum = {
    SignTypedData: 'signTypedData'
} as const;

export type SignRequestDtoRequestOneOf2ActionEnum = typeof SignRequestDtoRequestOneOf2ActionEnum[keyof typeof SignRequestDtoRequestOneOf2ActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedData
 */
export interface SignRequestDtoRequestOneOf2TypedData {
    /**
     * 
     * @type {SignRequestDtoRequestOneOf2TypedDataDomain}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'domain': SignRequestDtoRequestOneOf2TypedDataDomain;
    /**
     * 
     * @type {{ [key: string]: Array<SignRequestDtoRequestOneOf2TypedDataTypesValueInner>; }}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'types': { [key: string]: Array<SignRequestDtoRequestOneOf2TypedDataTypesValueInner>; };
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'primaryType': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'message': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedDataDomain
 */
export interface SignRequestDtoRequestOneOf2TypedDataDomain {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'version'?: string;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'chainId'?: number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'verifyingContract'?: any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'salt'?: any;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedDataTypesValueInner
 */
export interface SignRequestDtoRequestOneOf2TypedDataTypesValueInner {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataTypesValueInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataTypesValueInner
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf3
 */
export interface SignRequestDtoRequestOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'action': SignRequestDtoRequestOneOf3ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'resourceId': string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'rawMessage': any;
}

export const SignRequestDtoRequestOneOf3ActionEnum = {
    SignRaw: 'signRaw'
} as const;

export type SignRequestDtoRequestOneOf3ActionEnum = typeof SignRequestDtoRequestOneOf3ActionEnum[keyof typeof SignRequestDtoRequestOneOf3ActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf4
 */
export interface SignRequestDtoRequestOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4
     */
    'action': SignRequestDtoRequestOneOf4ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOf4UserOperation}
     * @memberof SignRequestDtoRequestOneOf4
     */
    'userOperation': SignRequestDtoRequestOneOf4UserOperation;
}

export const SignRequestDtoRequestOneOf4ActionEnum = {
    SignUserOperation: 'signUserOperation'
} as const;

export type SignRequestDtoRequestOneOf4ActionEnum = typeof SignRequestDtoRequestOneOf4ActionEnum[keyof typeof SignRequestDtoRequestOneOf4ActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf4UserOperation
 */
export interface SignRequestDtoRequestOneOf4UserOperation {
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'sender': any;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'nonce': string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'initCode': any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'callData': any;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'callGasLimit': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'verificationGasLimit': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'preVerificationGas': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'maxFeePerGas': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'maxPriorityFeePerGas': string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'paymasterAndData': any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'entryPoint': any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'signature': any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'factoryAddress': any;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'chainId': number;
}
/**
 * @type SignRequestDtoRequestOneOfTransactionRequest
 * @export
 */
export type SignRequestDtoRequestOneOfTransactionRequest = SignRequestDtoRequestOneOfTransactionRequestOneOf | SignRequestDtoRequestOneOfTransactionRequestOneOf1;

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOfTransactionRequestOneOf
 */
export interface SignRequestDtoRequestOneOfTransactionRequestOneOf {
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'chainId': number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'from': any;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'nonce'?: number;
    /**
     * 
     * @type {Array<SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner>}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'accessList'?: Array<SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner>;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'gas'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'maxFeePerGas'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'maxPriorityFeePerGas'?: string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'to'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'type'?: SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'value'?: any;
}

export const SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum = {
    _2: '2'
} as const;

export type SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum = typeof SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum[keyof typeof SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOfTransactionRequestOneOf1
 */
export interface SignRequestDtoRequestOneOfTransactionRequestOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'chainId': number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'from': any;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'nonce'?: number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'gas'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'gasPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'type'?: SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'to'?: any | null;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'value'?: any;
}

export const SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum = {
    _0: '0'
} as const;

export type SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum = typeof SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum[keyof typeof SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner
 */
export interface SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner {
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner
     */
    'address': any;
    /**
     * 
     * @type {Array<any>}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner
     */
    'storageKeys': Array<any>;
}
/**
 * 
 * @export
 * @interface SignatureDto
 */
export interface SignatureDto {
    /**
     * 
     * @type {any}
     * @memberof SignatureDto
     */
    'signature': any;
}
/**
 * 
 * @export
 * @interface WalletDto
 */
export interface WalletDto {
    /**
     * 
     * @type {WalletDtoAccount}
     * @memberof WalletDto
     */
    'account': WalletDtoAccount;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    'backup'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    'keyId': string;
}
/**
 * 
 * @export
 * @interface WalletDtoAccount
 */
export interface WalletDtoAccount {
    /**
     * 
     * @type {string}
     * @memberof WalletDtoAccount
     */
    'id': string;
    /**
     * 
     * @type {any}
     * @memberof WalletDtoAccount
     */
    'publicKey': any;
    /**
     * 
     * @type {any}
     * @memberof WalletDtoAccount
     */
    'address': any;
    /**
     * 
     * @type {WalletsDtoWalletsInnerOrigin}
     * @memberof WalletDtoAccount
     */
    'origin': WalletsDtoWalletsInnerOrigin;
    /**
     * 
     * @type {string}
     * @memberof WalletDtoAccount
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDtoAccount
     */
    'derivationPath'?: string;
}
/**
 * 
 * @export
 * @interface WalletsDto
 */
export interface WalletsDto {
    /**
     * 
     * @type {Array<WalletsDtoWalletsInner>}
     * @memberof WalletsDto
     */
    'wallets': Array<WalletsDtoWalletsInner>;
}
/**
 * 
 * @export
 * @interface WalletsDtoWalletsInner
 */
export interface WalletsDtoWalletsInner {
    /**
     * 
     * @type {string}
     * @memberof WalletsDtoWalletsInner
     */
    'keyId': string;
    /**
     * 
     * @type {string}
     * @memberof WalletsDtoWalletsInner
     */
    'curve': string;
    /**
     * 
     * @type {WalletsDtoWalletsInnerKeyType}
     * @memberof WalletsDtoWalletsInner
     */
    'keyType': WalletsDtoWalletsInnerKeyType;
    /**
     * 
     * @type {WalletsDtoWalletsInnerOrigin}
     * @memberof WalletsDtoWalletsInner
     */
    'origin': WalletsDtoWalletsInnerOrigin;
}
/**
 * @type WalletsDtoWalletsInnerKeyType
 * @export
 */
export type WalletsDtoWalletsInnerKeyType = string;

/**
 * @type WalletsDtoWalletsInnerOrigin
 * @export
 */
export type WalletsDtoWalletsInnerOrigin = string;


/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {DeriveAccountDto} deriveAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derive: async (xClientId: string, authorization: string, deriveAccountDto: DeriveAccountDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('derive', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('derive', 'authorization', authorization)
            // verify required parameter 'deriveAccountDto' is not null or undefined
            assertParamExists('derive', 'deriveAccountDto', deriveAccountDto)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deriveAccountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports an account
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportPrivateKeyDto} importPrivateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPrivateKey: async (xClientId: string, authorization: string, importPrivateKeyDto: ImportPrivateKeyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('importPrivateKey', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('importPrivateKey', 'authorization', authorization)
            // verify required parameter 'importPrivateKeyDto' is not null or undefined
            assertParamExists('importPrivateKey', 'importPrivateKeyDto', importPrivateKeyDto)
            const localVarPath = `/v1/accounts/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importPrivateKeyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('list', 'authorization', authorization)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {DeriveAccountDto} deriveAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async derive(xClientId: string, authorization: string, deriveAccountDto: DeriveAccountDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeriveAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.derive(xClientId, authorization, deriveAccountDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.derive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Imports an account
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportPrivateKeyDto} importPrivateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importPrivateKey(xClientId: string, authorization: string, importPrivateKeyDto: ImportPrivateKeyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importPrivateKey(xClientId, authorization, importPrivateKeyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.importPrivateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {DeriveAccountDto} deriveAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derive(xClientId: string, authorization: string, deriveAccountDto: DeriveAccountDto, options?: any): AxiosPromise<DeriveAccountResponseDto> {
            return localVarFp.derive(xClientId, authorization, deriveAccountDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Imports an account
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportPrivateKeyDto} importPrivateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPrivateKey(xClientId: string, authorization: string, importPrivateKeyDto: ImportPrivateKeyDto, options?: any): AxiosPromise<AccountDto> {
            return localVarFp.importPrivateKey(xClientId, authorization, importPrivateKeyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(xClientId: string, authorization: string, options?: any): AxiosPromise<AccountsDto> {
            return localVarFp.list(xClientId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Add a new account to a wallet
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {DeriveAccountDto} deriveAccountDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public derive(xClientId: string, authorization: string, deriveAccountDto: DeriveAccountDto, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).derive(xClientId, authorization, deriveAccountDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Imports an account
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {ImportPrivateKeyDto} importPrivateKeyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public importPrivateKey(xClientId: string, authorization: string, importPrivateKeyDto: ImportPrivateKeyDto, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).importPrivateKey(xClientId, authorization, importPrivateKeyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists the client accounts
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public list(xClientId: string, authorization: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).list(xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PongDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<PongDto> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {string} xApiKey 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (xApiKey: string, createClientDto: CreateClientDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('create', 'xApiKey', xApiKey)
            // verify required parameter 'createClientDto' is not null or undefined
            assertParamExists('create', 'createClientDto', createClientDto)
            const localVarPath = `/v1/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ADMIN_API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "ADMIN_API_KEY", configuration)

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClientDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {string} xApiKey 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(xApiKey: string, createClientDto: CreateClientDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(xApiKey, createClientDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {string} xApiKey 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(xApiKey: string, createClientDto: CreateClientDto, options?: any): AxiosPromise<ClientDto> {
            return localVarFp.create(xApiKey, createClientDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new client
     * @param {string} xApiKey 
     * @param {CreateClientDto} createClientDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public create(xApiKey: string, createClientDto: CreateClientDto, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).create(xApiKey, createClientDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EncryptionKeyApi - axios parameter creator
 * @export
 */
export const EncryptionKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (xClientId: string, authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generate', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('generate', 'authorization', authorization)
            const localVarPath = `/v1/encryption-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EncryptionKeyApi - functional programming interface
 * @export
 */
export const EncryptionKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EncryptionKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(xClientId: string, authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncryptionKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(xClientId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EncryptionKeyApi.generate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EncryptionKeyApi - factory interface
 * @export
 */
export const EncryptionKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EncryptionKeyApiFp(configuration)
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(xClientId: string, authorization: string, options?: any): AxiosPromise<EncryptionKeyDto> {
            return localVarFp.generate(xClientId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EncryptionKeyApi - object-oriented interface
 * @export
 * @class EncryptionKeyApi
 * @extends {BaseAPI}
 */
export class EncryptionKeyApi extends BaseAPI {
    /**
     * 
     * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncryptionKeyApi
     */
    public generate(xClientId: string, authorization: string, options?: RawAxiosRequestConfig) {
        return EncryptionKeyApiFp(this.configuration).generate(xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignApi - axios parameter creator
 * @export
 */
export const SignApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {SignRequestDto} signRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign: async (xClientId: string, authorization: string, signRequestDto: SignRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('sign', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('sign', 'authorization', authorization)
            // verify required parameter 'signRequestDto' is not null or undefined
            assertParamExists('sign', 'signRequestDto', signRequestDto)
            const localVarPath = `/v1/sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignApi - functional programming interface
 * @export
 */
export const SignApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {SignRequestDto} signRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sign(xClientId: string, authorization: string, signRequestDto: SignRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sign(xClientId, authorization, signRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignApi.sign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SignApi - factory interface
 * @export
 */
export const SignApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignApiFp(configuration)
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {SignRequestDto} signRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(xClientId: string, authorization: string, signRequestDto: SignRequestDto, options?: any): AxiosPromise<SignatureDto> {
            return localVarFp.sign(xClientId, authorization, signRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignApi - object-oriented interface
 * @export
 * @class SignApi
 * @extends {BaseAPI}
 */
export class SignApi extends BaseAPI {
    /**
     * 
     * @summary Signs the given request
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {SignRequestDto} signRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public sign(xClientId: string, authorization: string, signRequestDto: SignRequestDto, options?: RawAxiosRequestConfig) {
        return SignApiFp(this.configuration).sign(xClientId, authorization, signRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {GenerateWalletDto} generateWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (xClientId: string, authorization: string, generateWalletDto: GenerateWalletDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generate', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('generate', 'authorization', authorization)
            // verify required parameter 'generateWalletDto' is not null or undefined
            assertParamExists('generate', 'generateWalletDto', generateWalletDto)
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateWalletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportWalletDto} importWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSeed: async (xClientId: string, authorization: string, importWalletDto: ImportWalletDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('importSeed', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('importSeed', 'authorization', authorization)
            // verify required parameter 'importWalletDto' is not null or undefined
            assertParamExists('importSeed', 'importWalletDto', importWalletDto)
            const localVarPath = `/v1/wallets/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importWalletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('list', 'authorization', authorization)
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {GenerateWalletDto} generateWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(xClientId: string, authorization: string, generateWalletDto: GenerateWalletDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(xClientId, authorization, generateWalletDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.generate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportWalletDto} importWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importSeed(xClientId: string, authorization: string, importWalletDto: ImportWalletDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSeed(xClientId, authorization, importWalletDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.importSeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {GenerateWalletDto} generateWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(xClientId: string, authorization: string, generateWalletDto: GenerateWalletDto, options?: any): AxiosPromise<WalletDto> {
            return localVarFp.generate(xClientId, authorization, generateWalletDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportWalletDto} importWalletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSeed(xClientId: string, authorization: string, importWalletDto: ImportWalletDto, options?: any): AxiosPromise<WalletDto> {
            return localVarFp.importSeed(xClientId, authorization, importWalletDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(xClientId: string, authorization: string, options?: any): AxiosPromise<WalletsDto> {
            return localVarFp.list(xClientId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * 
     * @summary Generates a new wallet
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {GenerateWalletDto} generateWalletDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public generate(xClientId: string, authorization: string, generateWalletDto: GenerateWalletDto, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).generate(xClientId, authorization, generateWalletDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Imports a wallet
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {ImportWalletDto} importWalletDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public importSeed(xClientId: string, authorization: string, importWalletDto: ImportWalletDto, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).importSeed(xClientId, authorization, importWalletDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the client wallets
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public list(xClientId: string, authorization: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).list(xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



