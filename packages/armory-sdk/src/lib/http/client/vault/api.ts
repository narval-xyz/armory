/* tslint:disable */
/* eslint-disable */
/**
 * Vault
 * The next generation of authorization for web3
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountsDto
 */
export interface AccountsDto {
    /**
     * 
     * @type {Array<GenerateKeyResponseDtoAccount>}
     * @memberof AccountsDto
     */
    'accounts': Array<GenerateKeyResponseDtoAccount>;
}
/**
 * 
 * @export
 * @interface ClientDto
 */
export interface ClientDto {
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'clientId': string;
    /**
     * 
     * @type {CreateClientDtoEngineJwk}
     * @memberof ClientDto
     */
    'engineJwk'?: CreateClientDtoEngineJwk;
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'audience'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'issuer'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientDto
     */
    'maxTokenAge'?: number;
    /**
     * 
     * @type {CreateClientDtoEngineJwkOneOf2}
     * @memberof ClientDto
     */
    'backupPublicKey'?: CreateClientDtoEngineJwkOneOf2;
    /**
     * 
     * @type {boolean}
     * @memberof ClientDto
     */
    'allowKeyExport'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'baseUrl'?: string;
    /**
     * 
     * @type {any}
     * @memberof ClientDto
     */
    'createdAt': any;
    /**
     * 
     * @type {any}
     * @memberof ClientDto
     */
    'updatedAt': any;
}
/**
 * 
 * @export
 * @interface CreateClientDto
 */
export interface CreateClientDto {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'clientId'?: string;
    /**
     * 
     * @type {CreateClientDtoEngineJwk}
     * @memberof CreateClientDto
     */
    'engineJwk'?: CreateClientDtoEngineJwk;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'audience'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'issuer'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateClientDto
     */
    'maxTokenAge'?: number;
    /**
     * 
     * @type {CreateClientDtoEngineJwkOneOf2}
     * @memberof CreateClientDto
     */
    'backupPublicKey'?: CreateClientDtoEngineJwkOneOf2;
    /**
     * 
     * @type {boolean}
     * @memberof CreateClientDto
     */
    'allowKeyExport'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'baseUrl'?: string;
}
/**
 * @type CreateClientDtoEngineJwk
 * @export
 */
export type CreateClientDtoEngineJwk = CreateClientDtoEngineJwkOneOf | CreateClientDtoEngineJwkOneOf1 | CreateClientDtoEngineJwkOneOf2 | CreateClientDtoEngineJwkOneOf3;

/**
 * 
 * @export
 * @interface CreateClientDtoEngineJwkOneOf
 */
export interface CreateClientDtoEngineJwkOneOf {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'kty': CreateClientDtoEngineJwkOneOfKtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'alg': CreateClientDtoEngineJwkOneOfAlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'use'?: CreateClientDtoEngineJwkOneOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'crv': CreateClientDtoEngineJwkOneOfCrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'x': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf
     */
    'y': string;
}

export const CreateClientDtoEngineJwkOneOfKtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoEngineJwkOneOfKtyEnum = typeof CreateClientDtoEngineJwkOneOfKtyEnum[keyof typeof CreateClientDtoEngineJwkOneOfKtyEnum];
export const CreateClientDtoEngineJwkOneOfAlgEnum = {
    Es256K: 'ES256K'
} as const;

export type CreateClientDtoEngineJwkOneOfAlgEnum = typeof CreateClientDtoEngineJwkOneOfAlgEnum[keyof typeof CreateClientDtoEngineJwkOneOfAlgEnum];
export const CreateClientDtoEngineJwkOneOfUseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoEngineJwkOneOfUseEnum = typeof CreateClientDtoEngineJwkOneOfUseEnum[keyof typeof CreateClientDtoEngineJwkOneOfUseEnum];
export const CreateClientDtoEngineJwkOneOfCrvEnum = {
    Secp256k1: 'secp256k1'
} as const;

export type CreateClientDtoEngineJwkOneOfCrvEnum = typeof CreateClientDtoEngineJwkOneOfCrvEnum[keyof typeof CreateClientDtoEngineJwkOneOfCrvEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoEngineJwkOneOf1
 */
export interface CreateClientDtoEngineJwkOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'kty': CreateClientDtoEngineJwkOneOf1KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'alg': CreateClientDtoEngineJwkOneOf1AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'use'?: CreateClientDtoEngineJwkOneOf1UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'crv': CreateClientDtoEngineJwkOneOf1CrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'x': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf1
     */
    'y': string;
}

export const CreateClientDtoEngineJwkOneOf1KtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoEngineJwkOneOf1KtyEnum = typeof CreateClientDtoEngineJwkOneOf1KtyEnum[keyof typeof CreateClientDtoEngineJwkOneOf1KtyEnum];
export const CreateClientDtoEngineJwkOneOf1AlgEnum = {
    Es256: 'ES256'
} as const;

export type CreateClientDtoEngineJwkOneOf1AlgEnum = typeof CreateClientDtoEngineJwkOneOf1AlgEnum[keyof typeof CreateClientDtoEngineJwkOneOf1AlgEnum];
export const CreateClientDtoEngineJwkOneOf1UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoEngineJwkOneOf1UseEnum = typeof CreateClientDtoEngineJwkOneOf1UseEnum[keyof typeof CreateClientDtoEngineJwkOneOf1UseEnum];
export const CreateClientDtoEngineJwkOneOf1CrvEnum = {
    P256: 'P-256'
} as const;

export type CreateClientDtoEngineJwkOneOf1CrvEnum = typeof CreateClientDtoEngineJwkOneOf1CrvEnum[keyof typeof CreateClientDtoEngineJwkOneOf1CrvEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoEngineJwkOneOf2
 */
export interface CreateClientDtoEngineJwkOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'kty': CreateClientDtoEngineJwkOneOf2KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'alg': CreateClientDtoEngineJwkOneOf2AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'use'?: CreateClientDtoEngineJwkOneOf2UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'n': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf2
     */
    'e': string;
}

export const CreateClientDtoEngineJwkOneOf2KtyEnum = {
    Rsa: 'RSA'
} as const;

export type CreateClientDtoEngineJwkOneOf2KtyEnum = typeof CreateClientDtoEngineJwkOneOf2KtyEnum[keyof typeof CreateClientDtoEngineJwkOneOf2KtyEnum];
export const CreateClientDtoEngineJwkOneOf2AlgEnum = {
    Rs256: 'RS256'
} as const;

export type CreateClientDtoEngineJwkOneOf2AlgEnum = typeof CreateClientDtoEngineJwkOneOf2AlgEnum[keyof typeof CreateClientDtoEngineJwkOneOf2AlgEnum];
export const CreateClientDtoEngineJwkOneOf2UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoEngineJwkOneOf2UseEnum = typeof CreateClientDtoEngineJwkOneOf2UseEnum[keyof typeof CreateClientDtoEngineJwkOneOf2UseEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoEngineJwkOneOf3
 */
export interface CreateClientDtoEngineJwkOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'kty': CreateClientDtoEngineJwkOneOf3KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'crv': CreateClientDtoEngineJwkOneOf3CrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'alg': CreateClientDtoEngineJwkOneOf3AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'use'?: CreateClientDtoEngineJwkOneOf3UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'kid': string;
    /**
     * 
     * @type {any}
     * @memberof CreateClientDtoEngineJwkOneOf3
     */
    'addr': any;
}

export const CreateClientDtoEngineJwkOneOf3KtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoEngineJwkOneOf3KtyEnum = typeof CreateClientDtoEngineJwkOneOf3KtyEnum[keyof typeof CreateClientDtoEngineJwkOneOf3KtyEnum];
export const CreateClientDtoEngineJwkOneOf3CrvEnum = {
    Secp256k1: 'secp256k1'
} as const;

export type CreateClientDtoEngineJwkOneOf3CrvEnum = typeof CreateClientDtoEngineJwkOneOf3CrvEnum[keyof typeof CreateClientDtoEngineJwkOneOf3CrvEnum];
export const CreateClientDtoEngineJwkOneOf3AlgEnum = {
    Es256K: 'ES256K'
} as const;

export type CreateClientDtoEngineJwkOneOf3AlgEnum = typeof CreateClientDtoEngineJwkOneOf3AlgEnum[keyof typeof CreateClientDtoEngineJwkOneOf3AlgEnum];
export const CreateClientDtoEngineJwkOneOf3UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoEngineJwkOneOf3UseEnum = typeof CreateClientDtoEngineJwkOneOf3UseEnum[keyof typeof CreateClientDtoEngineJwkOneOf3UseEnum];

/**
 * 
 * @export
 * @interface DeriveAccountDto
 */
export interface DeriveAccountDto {
    /**
     * 
     * @type {string}
     * @memberof DeriveAccountDto
     */
    'keyId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeriveAccountDto
     */
    'derivationPaths'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DeriveAccountDto
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface DeriveAccountResponseDto
 */
export interface DeriveAccountResponseDto {
    /**
     * 
     * @type {Array<GenerateKeyResponseDtoAccount>}
     * @memberof DeriveAccountResponseDto
     */
    'accounts': Array<GenerateKeyResponseDtoAccount>;
}
/**
 * 
 * @export
 * @interface GenerateEncryptionKeyResponseDto
 */
export interface GenerateEncryptionKeyResponseDto {
    /**
     * 
     * @type {RsaPublicKeyDto}
     * @memberof GenerateEncryptionKeyResponseDto
     */
    'publicKey': RsaPublicKeyDto;
}
/**
 * 
 * @export
 * @interface GenerateKeyDto
 */
export interface GenerateKeyDto {
    /**
     * 
     * @type {GenerateKeyDtoCurve}
     * @memberof GenerateKeyDto
     */
    'curve'?: GenerateKeyDtoCurve;
    /**
     * 
     * @type {string}
     * @memberof GenerateKeyDto
     */
    'keyId'?: string;
}
/**
 * @type GenerateKeyDtoCurve
 * @export
 */
export type GenerateKeyDtoCurve = string;

/**
 * 
 * @export
 * @interface GenerateKeyResponseDto
 */
export interface GenerateKeyResponseDto {
    /**
     * 
     * @type {GenerateKeyResponseDtoAccount}
     * @memberof GenerateKeyResponseDto
     */
    'account': GenerateKeyResponseDtoAccount;
    /**
     * 
     * @type {string}
     * @memberof GenerateKeyResponseDto
     */
    'backup'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerateKeyResponseDto
     */
    'keyId': string;
}
/**
 * 
 * @export
 * @interface GenerateKeyResponseDtoAccount
 */
export interface GenerateKeyResponseDtoAccount {
    /**
     * 
     * @type {string}
     * @memberof GenerateKeyResponseDtoAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateKeyResponseDtoAccount
     */
    'address': string;
    /**
     * 
     * @type {any}
     * @memberof GenerateKeyResponseDtoAccount
     */
    'publicKey': any;
    /**
     * 
     * @type {string}
     * @memberof GenerateKeyResponseDtoAccount
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerateKeyResponseDtoAccount
     */
    'derivationPath'?: string;
}
/**
 * 
 * @export
 * @interface ImportPrivateKeyDto
 */
export interface ImportPrivateKeyDto {
    /**
     * Account Private Key, unencrypted
     * @type {object}
     * @memberof ImportPrivateKeyDto
     */
    'privateKey': object;
    /**
     * Account Private Key encrypted with JWE. Header MUST include `kid`
     * @type {string}
     * @memberof ImportPrivateKeyDto
     */
    'encryptedPrivateKey': string;
    /**
     * 
     * @type {string}
     * @memberof ImportPrivateKeyDto
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface ImportPrivateKeyResponseDto
 */
export interface ImportPrivateKeyResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ImportPrivateKeyResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImportPrivateKeyResponseDto
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface ImportSeedDto
 */
export interface ImportSeedDto {
    /**
     * 
     * @type {string}
     * @memberof ImportSeedDto
     */
    'keyId'?: string;
    /**
     * 
     * @type {GenerateKeyDtoCurve}
     * @memberof ImportSeedDto
     */
    'curve'?: GenerateKeyDtoCurve;
    /**
     * 
     * @type {string}
     * @memberof ImportSeedDto
     */
    'encryptedSeed': string;
}
/**
 * 
 * @export
 * @interface RsaPublicKeyDto
 */
export interface RsaPublicKeyDto {
    /**
     * 
     * @type {string}
     * @memberof RsaPublicKeyDto
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof RsaPublicKeyDto
     */
    'kty': RsaPublicKeyDtoKtyEnum;
    /**
     * 
     * @type {string}
     * @memberof RsaPublicKeyDto
     */
    'alg': RsaPublicKeyDtoAlgEnum;
    /**
     * A base64Url-encoded value
     * @type {string}
     * @memberof RsaPublicKeyDto
     */
    'n': string;
    /**
     * A base64Url-encoded value
     * @type {string}
     * @memberof RsaPublicKeyDto
     */
    'e': string;
    /**
     * 
     * @type {string}
     * @memberof RsaPublicKeyDto
     */
    'use': RsaPublicKeyDtoUseEnum;
}

export const RsaPublicKeyDtoKtyEnum = {
    Rsa: 'RSA'
} as const;

export type RsaPublicKeyDtoKtyEnum = typeof RsaPublicKeyDtoKtyEnum[keyof typeof RsaPublicKeyDtoKtyEnum];
export const RsaPublicKeyDtoAlgEnum = {
    Rs256: 'RS256'
} as const;

export type RsaPublicKeyDtoAlgEnum = typeof RsaPublicKeyDtoAlgEnum[keyof typeof RsaPublicKeyDtoAlgEnum];
export const RsaPublicKeyDtoUseEnum = {
    Enc: 'enc',
    Sig: 'sig'
} as const;

export type RsaPublicKeyDtoUseEnum = typeof RsaPublicKeyDtoUseEnum[keyof typeof RsaPublicKeyDtoUseEnum];

/**
 * 
 * @export
 * @interface SignRequestDto
 */
export interface SignRequestDto {
    /**
     * 
     * @type {SignRequestDtoRequest}
     * @memberof SignRequestDto
     */
    'request': SignRequestDtoRequest;
}
/**
 * @type SignRequestDtoRequest
 * @export
 */
export type SignRequestDtoRequest = SignRequestDtoRequestOneOf | SignRequestDtoRequestOneOf1 | SignRequestDtoRequestOneOf2 | SignRequestDtoRequestOneOf3;

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf
 */
export interface SignRequestDtoRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'action': SignRequestDtoRequestOneOfActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOfTransactionRequest}
     * @memberof SignRequestDtoRequestOneOf
     */
    'transactionRequest': SignRequestDtoRequestOneOfTransactionRequest;
}

export const SignRequestDtoRequestOneOfActionEnum = {
    SignTransaction: 'signTransaction'
} as const;

export type SignRequestDtoRequestOneOfActionEnum = typeof SignRequestDtoRequestOneOfActionEnum[keyof typeof SignRequestDtoRequestOneOfActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf1
 */
export interface SignRequestDtoRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'action': SignRequestDtoRequestOneOf1ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOf1Message}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'message': SignRequestDtoRequestOneOf1Message;
}

export const SignRequestDtoRequestOneOf1ActionEnum = {
    SignMessage: 'signMessage'
} as const;

export type SignRequestDtoRequestOneOf1ActionEnum = typeof SignRequestDtoRequestOneOf1ActionEnum[keyof typeof SignRequestDtoRequestOneOf1ActionEnum];

/**
 * @type SignRequestDtoRequestOneOf1Message
 * @export
 */
export type SignRequestDtoRequestOneOf1Message = SignRequestDtoRequestOneOf1MessageOneOf | string;

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf1MessageOneOf
 */
export interface SignRequestDtoRequestOneOf1MessageOneOf {
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf1MessageOneOf
     */
    'raw': any;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2
 */
export interface SignRequestDtoRequestOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'action': SignRequestDtoRequestOneOf2ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOf2TypedData}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'typedData': SignRequestDtoRequestOneOf2TypedData;
}

export const SignRequestDtoRequestOneOf2ActionEnum = {
    SignTypedData: 'signTypedData'
} as const;

export type SignRequestDtoRequestOneOf2ActionEnum = typeof SignRequestDtoRequestOneOf2ActionEnum[keyof typeof SignRequestDtoRequestOneOf2ActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedData
 */
export interface SignRequestDtoRequestOneOf2TypedData {
    /**
     * 
     * @type {SignRequestDtoRequestOneOf2TypedDataDomain}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'domain': SignRequestDtoRequestOneOf2TypedDataDomain;
    /**
     * 
     * @type {{ [key: string]: Array<SignRequestDtoRequestOneOf2TypedDataTypesValueInner>; }}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'types': { [key: string]: Array<SignRequestDtoRequestOneOf2TypedDataTypesValueInner>; };
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'primaryType': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'message': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedDataDomain
 */
export interface SignRequestDtoRequestOneOf2TypedDataDomain {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'version'?: string;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'chainId'?: number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'verifyingContract'?: any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'salt'?: any;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedDataTypesValueInner
 */
export interface SignRequestDtoRequestOneOf2TypedDataTypesValueInner {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataTypesValueInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataTypesValueInner
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf3
 */
export interface SignRequestDtoRequestOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'action': SignRequestDtoRequestOneOf3ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'resourceId': string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'rawMessage': any;
}

export const SignRequestDtoRequestOneOf3ActionEnum = {
    SignRaw: 'signRaw'
} as const;

export type SignRequestDtoRequestOneOf3ActionEnum = typeof SignRequestDtoRequestOneOf3ActionEnum[keyof typeof SignRequestDtoRequestOneOf3ActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOfTransactionRequest
 */
export interface SignRequestDtoRequestOneOfTransactionRequest {
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'chainId': number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'from': any;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'nonce'?: number;
    /**
     * 
     * @type {Array<SignRequestDtoRequestOneOfTransactionRequestAccessListInner>}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'accessList'?: Array<SignRequestDtoRequestOneOfTransactionRequestAccessListInner>;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'data'?: any;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'gas'?: number;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'maxFeePerGas'?: number;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'maxPriorityFeePerGas'?: number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'to'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'type'?: SignRequestDtoRequestOneOfTransactionRequestTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequest
     */
    'value'?: any;
}

export const SignRequestDtoRequestOneOfTransactionRequestTypeEnum = {
    _2: '2'
} as const;

export type SignRequestDtoRequestOneOfTransactionRequestTypeEnum = typeof SignRequestDtoRequestOneOfTransactionRequestTypeEnum[keyof typeof SignRequestDtoRequestOneOfTransactionRequestTypeEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOfTransactionRequestAccessListInner
 */
export interface SignRequestDtoRequestOneOfTransactionRequestAccessListInner {
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestAccessListInner
     */
    'address': any;
    /**
     * 
     * @type {Array<any>}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestAccessListInner
     */
    'storageKeys': Array<any>;
}
/**
 * 
 * @export
 * @interface SignatureDto
 */
export interface SignatureDto {
    /**
     * 
     * @type {any}
     * @memberof SignatureDto
     */
    'signature': any;
}
/**
 * 
 * @export
 * @interface WalletsDto
 */
export interface WalletsDto {
    /**
     * 
     * @type {Array<WalletsDtoWalletsInner>}
     * @memberof WalletsDto
     */
    'wallets': Array<WalletsDtoWalletsInner>;
}
/**
 * 
 * @export
 * @interface WalletsDtoWalletsInner
 */
export interface WalletsDtoWalletsInner {
    /**
     * 
     * @type {string}
     * @memberof WalletsDtoWalletsInner
     */
    'keyId': string;
    /**
     * 
     * @type {string}
     * @memberof WalletsDtoWalletsInner
     */
    'curve': string;
    /**
     * 
     * @type {WalletsDtoWalletsInnerKeyType}
     * @memberof WalletsDtoWalletsInner
     */
    'keyType': WalletsDtoWalletsInnerKeyType;
    /**
     * 
     * @type {WalletsDtoWalletsInnerOrigin}
     * @memberof WalletsDtoWalletsInner
     */
    'origin': WalletsDtoWalletsInnerOrigin;
}
/**
 * @type WalletsDtoWalletsInnerKeyType
 * @export
 */
export type WalletsDtoWalletsInnerKeyType = string;

/**
 * @type WalletsDtoWalletsInnerOrigin
 * @export
 */
export type WalletsDtoWalletsInnerOrigin = string;


/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {DeriveAccountDto} deriveAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKey: async (xClientId: string, authorization: string, deriveAccountDto: DeriveAccountDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generateKey', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('generateKey', 'authorization', authorization)
            // verify required parameter 'deriveAccountDto' is not null or undefined
            assertParamExists('generateKey', 'deriveAccountDto', deriveAccountDto)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deriveAccountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {string} xClientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (xClientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getAccounts', 'xClientId', xClientId)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports an account
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportPrivateKeyDto} importPrivateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPrivateKey: async (xClientId: string, authorization: string, importPrivateKeyDto: ImportPrivateKeyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('importPrivateKey', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('importPrivateKey', 'authorization', authorization)
            // verify required parameter 'importPrivateKeyDto' is not null or undefined
            assertParamExists('importPrivateKey', 'importPrivateKeyDto', importPrivateKeyDto)
            const localVarPath = `/accounts/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importPrivateKeyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {DeriveAccountDto} deriveAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKey(xClientId: string, authorization: string, deriveAccountDto: DeriveAccountDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeriveAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKey(xClientId, authorization, deriveAccountDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.generateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {string} xClientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(xClientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(xClientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.getAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Imports an account
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportPrivateKeyDto} importPrivateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importPrivateKey(xClientId: string, authorization: string, importPrivateKeyDto: ImportPrivateKeyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportPrivateKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importPrivateKey(xClientId, authorization, importPrivateKeyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.importPrivateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {DeriveAccountDto} deriveAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKey(xClientId: string, authorization: string, deriveAccountDto: DeriveAccountDto, options?: any): AxiosPromise<DeriveAccountResponseDto> {
            return localVarFp.generateKey(xClientId, authorization, deriveAccountDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {string} xClientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(xClientId: string, options?: any): AxiosPromise<AccountsDto> {
            return localVarFp.getAccounts(xClientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Imports an account
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportPrivateKeyDto} importPrivateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPrivateKey(xClientId: string, authorization: string, importPrivateKeyDto: ImportPrivateKeyDto, options?: any): AxiosPromise<ImportPrivateKeyResponseDto> {
            return localVarFp.importPrivateKey(xClientId, authorization, importPrivateKeyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Add a new account to a wallet
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {DeriveAccountDto} deriveAccountDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public generateKey(xClientId: string, authorization: string, deriveAccountDto: DeriveAccountDto, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).generateKey(xClientId, authorization, deriveAccountDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists the client accounts
     * @param {string} xClientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccounts(xClientId: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccounts(xClientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Imports an account
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {ImportPrivateKeyDto} importPrivateKeyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public importPrivateKey(xClientId: string, authorization: string, importPrivateKeyDto: ImportPrivateKeyDto, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).importPrivateKey(xClientId, authorization, importPrivateKeyDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {string} xApiKey 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (xApiKey: string, createClientDto: CreateClientDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('create', 'xApiKey', xApiKey)
            // verify required parameter 'createClientDto' is not null or undefined
            assertParamExists('create', 'createClientDto', createClientDto)
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ADMIN_API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "ADMIN_API_KEY", configuration)

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClientDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {string} xApiKey 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(xApiKey: string, createClientDto: CreateClientDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(xApiKey, createClientDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {string} xApiKey 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(xApiKey: string, createClientDto: CreateClientDto, options?: any): AxiosPromise<ClientDto> {
            return localVarFp.create(xApiKey, createClientDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new client
     * @param {string} xApiKey 
     * @param {CreateClientDto} createClientDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public create(xApiKey: string, createClientDto: CreateClientDto, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).create(xApiKey, createClientDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EncryptionKeyApi - axios parameter creator
 * @export
 */
export const EncryptionKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEncryptionKey: async (xClientId: string, authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generateEncryptionKey', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('generateEncryptionKey', 'authorization', authorization)
            const localVarPath = `/encryption-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EncryptionKeyApi - functional programming interface
 * @export
 */
export const EncryptionKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EncryptionKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateEncryptionKey(xClientId: string, authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateEncryptionKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateEncryptionKey(xClientId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EncryptionKeyApi.generateEncryptionKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EncryptionKeyApi - factory interface
 * @export
 */
export const EncryptionKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EncryptionKeyApiFp(configuration)
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateEncryptionKey(xClientId: string, authorization: string, options?: any): AxiosPromise<GenerateEncryptionKeyResponseDto> {
            return localVarFp.generateEncryptionKey(xClientId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EncryptionKeyApi - object-oriented interface
 * @export
 * @class EncryptionKeyApi
 * @extends {BaseAPI}
 */
export class EncryptionKeyApi extends BaseAPI {
    /**
     * 
     * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncryptionKeyApi
     */
    public generateEncryptionKey(xClientId: string, authorization: string, options?: RawAxiosRequestConfig) {
        return EncryptionKeyApiFp(this.configuration).generateEncryptionKey(xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignApi - axios parameter creator
 * @export
 */
export const SignApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {SignRequestDto} signRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign: async (xClientId: string, authorization: string, signRequestDto: SignRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('sign', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('sign', 'authorization', authorization)
            // verify required parameter 'signRequestDto' is not null or undefined
            assertParamExists('sign', 'signRequestDto', signRequestDto)
            const localVarPath = `/sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignApi - functional programming interface
 * @export
 */
export const SignApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {SignRequestDto} signRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sign(xClientId: string, authorization: string, signRequestDto: SignRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sign(xClientId, authorization, signRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignApi.sign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SignApi - factory interface
 * @export
 */
export const SignApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignApiFp(configuration)
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {SignRequestDto} signRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(xClientId: string, authorization: string, signRequestDto: SignRequestDto, options?: any): AxiosPromise<SignatureDto> {
            return localVarFp.sign(xClientId, authorization, signRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignApi - object-oriented interface
 * @export
 * @class SignApi
 * @extends {BaseAPI}
 */
export class SignApi extends BaseAPI {
    /**
     * 
     * @summary Signs the given request
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {SignRequestDto} signRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public sign(xClientId: string, authorization: string, signRequestDto: SignRequestDto, options?: RawAxiosRequestConfig) {
        return SignApiFp(this.configuration).sign(xClientId, authorization, signRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {GenerateKeyDto} generateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKey: async (xClientId: string, authorization: string, generateKeyDto: GenerateKeyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generateKey', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('generateKey', 'authorization', authorization)
            // verify required parameter 'generateKeyDto' is not null or undefined
            assertParamExists('generateKey', 'generateKeyDto', generateKeyDto)
            const localVarPath = `/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateKeyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeeds: async (xClientId: string, authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getSeeds', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getSeeds', 'authorization', authorization)
            const localVarPath = `/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportSeedDto} importSeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importKey: async (xClientId: string, authorization: string, importSeedDto: ImportSeedDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('importKey', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('importKey', 'authorization', authorization)
            // verify required parameter 'importSeedDto' is not null or undefined
            assertParamExists('importKey', 'importSeedDto', importSeedDto)
            const localVarPath = `/wallets/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importSeedDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {GenerateKeyDto} generateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKey(xClientId: string, authorization: string, generateKeyDto: GenerateKeyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKey(xClientId, authorization, generateKeyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.generateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeeds(xClientId: string, authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSeeds(xClientId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getSeeds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportSeedDto} importSeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importKey(xClientId: string, authorization: string, importSeedDto: ImportSeedDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importKey(xClientId, authorization, importSeedDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.importKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {GenerateKeyDto} generateKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKey(xClientId: string, authorization: string, generateKeyDto: GenerateKeyDto, options?: any): AxiosPromise<GenerateKeyResponseDto> {
            return localVarFp.generateKey(xClientId, authorization, generateKeyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeeds(xClientId: string, authorization: string, options?: any): AxiosPromise<WalletsDto> {
            return localVarFp.getSeeds(xClientId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {string} xClientId 
         * @param {string} authorization 
         * @param {ImportSeedDto} importSeedDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importKey(xClientId: string, authorization: string, importSeedDto: ImportSeedDto, options?: any): AxiosPromise<GenerateKeyResponseDto> {
            return localVarFp.importKey(xClientId, authorization, importSeedDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * 
     * @summary Generates a new wallet
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {GenerateKeyDto} generateKeyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public generateKey(xClientId: string, authorization: string, generateKeyDto: GenerateKeyDto, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).generateKey(xClientId, authorization, generateKeyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the client wallets
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getSeeds(xClientId: string, authorization: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getSeeds(xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Imports a wallet
     * @param {string} xClientId 
     * @param {string} authorization 
     * @param {ImportSeedDto} importSeedDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public importKey(xClientId: string, authorization: string, importSeedDto: ImportSeedDto, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).importKey(xClientId, authorization, importSeedDto, options).then((request) => request(this.axios, this.basePath));
    }
}



