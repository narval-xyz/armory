/* tslint:disable */
/* eslint-disable */
/**
 * Vault
 * Secure storage for private keys and sensitive data, designed to protect your most critical assets in web3.0
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'id': string;
    /**
     * 
     * @type {any}
     * @memberof AccountDto
     */
    'publicKey': any;
    /**
     * 
     * @type {any}
     * @memberof AccountDto
     */
    'address': any;
    /**
     * 
     * @type {WalletsDtoWalletsInnerOrigin}
     * @memberof AccountDto
     */
    'origin': WalletsDtoWalletsInnerOrigin;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'derivationPath'?: string;
}
/**
 * 
 * @export
 * @interface AccountsDto
 */
export interface AccountsDto {
    /**
     * 
     * @type {Array<WalletDtoAccount>}
     * @memberof AccountsDto
     */
    'accounts': Array<WalletDtoAccount>;
}
/**
 * 
 * @export
 * @interface ClientDto
 */
export interface ClientDto {
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'name': string;
    /**
     * 
     * @type {ClientDtoConfigurationSource}
     * @memberof ClientDto
     */
    'configurationSource': ClientDtoConfigurationSource;
    /**
     * 
     * @type {ClientDtoBackupPublicKey}
     * @memberof ClientDto
     */
    'backupPublicKey': ClientDtoBackupPublicKey | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDto
     */
    'baseUrl': string | null;
    /**
     * 
     * @type {ClientDtoAuth}
     * @memberof ClientDto
     */
    'auth': ClientDtoAuth;
    /**
     * 
     * @type {any}
     * @memberof ClientDto
     */
    'createdAt': any;
    /**
     * 
     * @type {any}
     * @memberof ClientDto
     */
    'updatedAt': any;
}
/**
 * 
 * @export
 * @interface ClientDtoAuth
 */
export interface ClientDtoAuth {
    /**
     * 
     * @type {boolean}
     * @memberof ClientDtoAuth
     */
    'disabled': boolean;
    /**
     * 
     * @type {ClientDtoAuthLocal}
     * @memberof ClientDtoAuth
     */
    'local': ClientDtoAuthLocal | null;
    /**
     * 
     * @type {ClientDtoAuthTokenValidation}
     * @memberof ClientDtoAuth
     */
    'tokenValidation': ClientDtoAuthTokenValidation;
}
/**
 * 
 * @export
 * @interface ClientDtoAuthLocal
 */
export interface ClientDtoAuthLocal {
    /**
     * 
     * @type {ClientDtoAuthLocalJwsd}
     * @memberof ClientDtoAuthLocal
     */
    'jwsd': ClientDtoAuthLocalJwsd;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoAuthLocal
     */
    'allowedUsersJwksUrl': string | null;
    /**
     * 
     * @type {Array<CreateClientDtoAuthLocalAllowedUsersInner>}
     * @memberof ClientDtoAuthLocal
     */
    'allowedUsers': Array<CreateClientDtoAuthLocalAllowedUsersInner> | null;
}
/**
 * 
 * @export
 * @interface ClientDtoAuthLocalJwsd
 */
export interface ClientDtoAuthLocalJwsd {
    /**
     * 
     * @type {number}
     * @memberof ClientDtoAuthLocalJwsd
     */
    'maxAge': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientDtoAuthLocalJwsd
     */
    'requiredComponents': Array<string>;
}
/**
 * 
 * @export
 * @interface ClientDtoAuthTokenValidation
 */
export interface ClientDtoAuthTokenValidation {
    /**
     * 
     * @type {boolean}
     * @memberof ClientDtoAuthTokenValidation
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoAuthTokenValidation
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoAuthTokenValidation
     */
    'jwksUrl': string | null;
    /**
     * 
     * @type {CreateClientDtoAuthTokenValidationPinnedPublicKey}
     * @memberof ClientDtoAuthTokenValidation
     */
    'pinnedPublicKey': CreateClientDtoAuthTokenValidationPinnedPublicKey | null;
    /**
     * 
     * @type {ClientDtoAuthTokenValidationVerification}
     * @memberof ClientDtoAuthTokenValidation
     */
    'verification': ClientDtoAuthTokenValidationVerification;
}
/**
 * 
 * @export
 * @interface ClientDtoAuthTokenValidationVerification
 */
export interface ClientDtoAuthTokenValidationVerification {
    /**
     * 
     * @type {string}
     * @memberof ClientDtoAuthTokenValidationVerification
     */
    'audience': string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoAuthTokenValidationVerification
     */
    'issuer': string | null;
    /**
     * 
     * @type {number}
     * @memberof ClientDtoAuthTokenValidationVerification
     */
    'maxTokenAge': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClientDtoAuthTokenValidationVerification
     */
    'requireBoundTokens': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientDtoAuthTokenValidationVerification
     */
    'allowBearerTokens': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientDtoAuthTokenValidationVerification
     */
    'allowWildcard': Array<string> | null;
}
/**
 * 
 * @export
 * @interface ClientDtoBackupPublicKey
 */
export interface ClientDtoBackupPublicKey {
    /**
     * 
     * @type {string}
     * @memberof ClientDtoBackupPublicKey
     */
    'kty': ClientDtoBackupPublicKeyKtyEnum;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoBackupPublicKey
     */
    'alg': ClientDtoBackupPublicKeyAlgEnum;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoBackupPublicKey
     */
    'use'?: ClientDtoBackupPublicKeyUseEnum;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoBackupPublicKey
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoBackupPublicKey
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoBackupPublicKey
     */
    'n': string;
    /**
     * 
     * @type {string}
     * @memberof ClientDtoBackupPublicKey
     */
    'e': string;
}

export const ClientDtoBackupPublicKeyKtyEnum = {
    Rsa: 'RSA'
} as const;

export type ClientDtoBackupPublicKeyKtyEnum = typeof ClientDtoBackupPublicKeyKtyEnum[keyof typeof ClientDtoBackupPublicKeyKtyEnum];
export const ClientDtoBackupPublicKeyAlgEnum = {
    Rs256: 'RS256'
} as const;

export type ClientDtoBackupPublicKeyAlgEnum = typeof ClientDtoBackupPublicKeyAlgEnum[keyof typeof ClientDtoBackupPublicKeyAlgEnum];
export const ClientDtoBackupPublicKeyUseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type ClientDtoBackupPublicKeyUseEnum = typeof ClientDtoBackupPublicKeyUseEnum[keyof typeof ClientDtoBackupPublicKeyUseEnum];

/**
 * @type ClientDtoConfigurationSource
 * @export
 */
export type ClientDtoConfigurationSource = string;

/**
 * 
 * @export
 * @interface CreateClientDto
 */
export interface CreateClientDto {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'baseUrl'?: string;
    /**
     * 
     * @type {CreateClientDtoBackupPublicKey}
     * @memberof CreateClientDto
     */
    'backupPublicKey'?: CreateClientDtoBackupPublicKey;
    /**
     * 
     * @type {CreateClientDtoAuth}
     * @memberof CreateClientDto
     */
    'auth'?: CreateClientDtoAuth;
    /**
     * 
     * @type {CreateClientDtoAuthLocalAllowedUsersInnerPublicKey}
     * @memberof CreateClientDto
     */
    'engineJwk'?: CreateClientDtoAuthLocalAllowedUsersInnerPublicKey;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'audience'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDto
     */
    'issuer'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateClientDto
     */
    'maxTokenAge'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateClientDto
     */
    'allowWildcard'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateClientDto
     */
    'allowKeyExport'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateClientDtoAuth
 */
export interface CreateClientDtoAuth {
    /**
     * 
     * @type {CreateClientDtoAuthLocal}
     * @memberof CreateClientDtoAuth
     */
    'local'?: CreateClientDtoAuthLocal | null;
    /**
     * 
     * @type {CreateClientDtoAuthTokenValidation}
     * @memberof CreateClientDtoAuth
     */
    'tokenValidation'?: CreateClientDtoAuthTokenValidation;
}
/**
 * 
 * @export
 * @interface CreateClientDtoAuthLocal
 */
export interface CreateClientDtoAuthLocal {
    /**
     * 
     * @type {CreateClientDtoAuthLocalJwsd}
     * @memberof CreateClientDtoAuthLocal
     */
    'jwsd'?: CreateClientDtoAuthLocalJwsd | null;
    /**
     * Pin specific users to be authorized; if set, ONLY these users are allowed
     * @type {Array<CreateClientDtoAuthLocalAllowedUsersInner>}
     * @memberof CreateClientDtoAuthLocal
     */
    'allowedUsers'?: Array<CreateClientDtoAuthLocalAllowedUsersInner> | null;
}
/**
 * 
 * @export
 * @interface CreateClientDtoAuthLocalAllowedUsersInner
 */
export interface CreateClientDtoAuthLocalAllowedUsersInner {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInner
     */
    'userId': string;
    /**
     * 
     * @type {CreateClientDtoAuthLocalAllowedUsersInnerPublicKey}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInner
     */
    'publicKey': CreateClientDtoAuthLocalAllowedUsersInnerPublicKey;
}
/**
 * @type CreateClientDtoAuthLocalAllowedUsersInnerPublicKey
 * @export
 */
export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKey = CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1 | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2 | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3 | CreateClientDtoBackupPublicKey;

/**
 * 
 * @export
 * @interface CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
 */
export interface CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
     */
    'kty': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfKtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
     */
    'alg': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfAlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
     */
    'use'?: CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
     */
    'crv': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfCrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
     */
    'x': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf
     */
    'y': string;
}

export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfKtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfKtyEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfKtyEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfKtyEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfAlgEnum = {
    Es256K: 'ES256K'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfAlgEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfAlgEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfAlgEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfUseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfUseEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfUseEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfUseEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfCrvEnum = {
    Secp256k1: 'secp256k1'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfCrvEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfCrvEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOfCrvEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
 */
export interface CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
     */
    'kty': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
     */
    'alg': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
     */
    'use'?: CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
     */
    'crv': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1CrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
     */
    'x': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1
     */
    'y': string;
}

export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1KtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1KtyEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1KtyEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1KtyEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1AlgEnum = {
    Es256: 'ES256'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1AlgEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1AlgEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1AlgEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1UseEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1UseEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1UseEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1CrvEnum = {
    P256: 'P-256'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1CrvEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1CrvEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1CrvEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2
 */
export interface CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2
     */
    'kty': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2
     */
    'crv': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2CrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2
     */
    'alg': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2
     */
    'use'?: CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2
     */
    'kid': string;
    /**
     * 
     * @type {any}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2
     */
    'addr': any;
}

export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2KtyEnum = {
    Ec: 'EC'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2KtyEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2KtyEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2KtyEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2CrvEnum = {
    Secp256k1: 'secp256k1'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2CrvEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2CrvEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2CrvEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2AlgEnum = {
    Es256K: 'ES256K'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2AlgEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2AlgEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2AlgEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2UseEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2UseEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2UseEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3
 */
export interface CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3
     */
    'kty': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3KtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3
     */
    'alg': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3AlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3
     */
    'use'?: CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3UseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3
     */
    'crv': CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3CrvEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3
     */
    'x': string;
}

export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3KtyEnum = {
    Okp: 'OKP'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3KtyEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3KtyEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3KtyEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3AlgEnum = {
    Eddsa: 'EDDSA'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3AlgEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3AlgEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3AlgEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3UseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3UseEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3UseEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3UseEnum];
export const CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3CrvEnum = {
    Ed25519: 'Ed25519'
} as const;

export type CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3CrvEnum = typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3CrvEnum[keyof typeof CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3CrvEnum];

/**
 * 
 * @export
 * @interface CreateClientDtoAuthLocalJwsd
 */
export interface CreateClientDtoAuthLocalJwsd {
    /**
     * 
     * @type {number}
     * @memberof CreateClientDtoAuthLocalJwsd
     */
    'maxAge'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateClientDtoAuthLocalJwsd
     */
    'requiredComponents'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateClientDtoAuthTokenValidation
 */
export interface CreateClientDtoAuthTokenValidation {
    /**
     * 
     * @type {boolean}
     * @memberof CreateClientDtoAuthTokenValidation
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthTokenValidation
     */
    'url'?: string | null;
    /**
     * 
     * @type {CreateClientDtoAuthTokenValidationPinnedPublicKey}
     * @memberof CreateClientDtoAuthTokenValidation
     */
    'pinnedPublicKey'?: CreateClientDtoAuthTokenValidationPinnedPublicKey | null;
    /**
     * 
     * @type {CreateClientDtoAuthTokenValidationVerification}
     * @memberof CreateClientDtoAuthTokenValidation
     */
    'verification'?: CreateClientDtoAuthTokenValidationVerification;
}
/**
 * @type CreateClientDtoAuthTokenValidationPinnedPublicKey
 * @export
 */
export type CreateClientDtoAuthTokenValidationPinnedPublicKey = CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1 | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2 | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3 | CreateClientDtoBackupPublicKey;

/**
 * 
 * @export
 * @interface CreateClientDtoAuthTokenValidationVerification
 */
export interface CreateClientDtoAuthTokenValidationVerification {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthTokenValidationVerification
     */
    'audience'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoAuthTokenValidationVerification
     */
    'issuer'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateClientDtoAuthTokenValidationVerification
     */
    'maxTokenAge'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateClientDtoAuthTokenValidationVerification
     */
    'requireBoundTokens'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateClientDtoAuthTokenValidationVerification
     */
    'allowBearerTokens'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateClientDtoAuthTokenValidationVerification
     */
    'allowWildcard'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateClientDtoBackupPublicKey
 */
export interface CreateClientDtoBackupPublicKey {
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoBackupPublicKey
     */
    'kty': CreateClientDtoBackupPublicKeyKtyEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoBackupPublicKey
     */
    'alg': CreateClientDtoBackupPublicKeyAlgEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoBackupPublicKey
     */
    'use'?: CreateClientDtoBackupPublicKeyUseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoBackupPublicKey
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoBackupPublicKey
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoBackupPublicKey
     */
    'n': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClientDtoBackupPublicKey
     */
    'e': string;
}

export const CreateClientDtoBackupPublicKeyKtyEnum = {
    Rsa: 'RSA'
} as const;

export type CreateClientDtoBackupPublicKeyKtyEnum = typeof CreateClientDtoBackupPublicKeyKtyEnum[keyof typeof CreateClientDtoBackupPublicKeyKtyEnum];
export const CreateClientDtoBackupPublicKeyAlgEnum = {
    Rs256: 'RS256'
} as const;

export type CreateClientDtoBackupPublicKeyAlgEnum = typeof CreateClientDtoBackupPublicKeyAlgEnum[keyof typeof CreateClientDtoBackupPublicKeyAlgEnum];
export const CreateClientDtoBackupPublicKeyUseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type CreateClientDtoBackupPublicKeyUseEnum = typeof CreateClientDtoBackupPublicKeyUseEnum[keyof typeof CreateClientDtoBackupPublicKeyUseEnum];

/**
 * 
 * @export
 * @interface CreateConnectionDto
 */
export interface CreateConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof CreateConnectionDto
     */
    'connectionId'?: string;
    /**
     * 
     * @type {any}
     * @memberof CreateConnectionDto
     */
    'createdAt'?: any;
    /**
     * RSA encrypted JSON string of the credentials
     * @type {string}
     * @memberof CreateConnectionDto
     */
    'encryptedCredentials'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectionDto
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectionDto
     */
    'provider': CreateConnectionDtoProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectionDto
     */
    'url': string;
    /**
     * 
     * @type {any}
     * @memberof CreateConnectionDto
     */
    'credentials'?: any;
}

export const CreateConnectionDtoProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type CreateConnectionDtoProviderEnum = typeof CreateConnectionDtoProviderEnum[keyof typeof CreateConnectionDtoProviderEnum];

/**
 * 
 * @export
 * @interface DeriveAccountDto
 */
export interface DeriveAccountDto {
    /**
     * 
     * @type {string}
     * @memberof DeriveAccountDto
     */
    'keyId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeriveAccountDto
     */
    'derivationPaths'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DeriveAccountDto
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface DeriveAccountResponseDto
 */
export interface DeriveAccountResponseDto {
    /**
     * 
     * @type {Array<WalletDtoAccount>}
     * @memberof DeriveAccountResponseDto
     */
    'accounts': Array<WalletDtoAccount>;
}
/**
 * 
 * @export
 * @interface EncryptionKeyDto
 */
export interface EncryptionKeyDto {
    /**
     * 
     * @type {EncryptionKeyDtoPublicKey}
     * @memberof EncryptionKeyDto
     */
    'publicKey': EncryptionKeyDtoPublicKey;
    /**
     * 
     * @type {EncryptionKeyDtoData}
     * @memberof EncryptionKeyDto
     */
    'data': EncryptionKeyDtoData;
}
/**
 * 
 * @export
 * @interface EncryptionKeyDtoData
 */
export interface EncryptionKeyDtoData {
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoData
     */
    'keyId'?: string;
    /**
     * 
     * @type {EncryptionKeyDtoDataJwk}
     * @memberof EncryptionKeyDtoData
     */
    'jwk'?: EncryptionKeyDtoDataJwk;
    /**
     * Base64url encoded PEM public key
     * @type {string}
     * @memberof EncryptionKeyDtoData
     */
    'pem'?: string;
}
/**
 * @type EncryptionKeyDtoDataJwk
 * JWK format of the public key
 * @export
 */
export type EncryptionKeyDtoDataJwk = CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf1 | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf2 | CreateClientDtoAuthLocalAllowedUsersInnerPublicKeyOneOf3 | CreateClientDtoBackupPublicKey;

/**
 * (DEPRECATED: use data.jwk instead) JWK format of the public key
 * @export
 * @interface EncryptionKeyDtoPublicKey
 */
export interface EncryptionKeyDtoPublicKey {
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'kty': EncryptionKeyDtoPublicKeyKtyEnum;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'alg': EncryptionKeyDtoPublicKeyAlgEnum;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'use'?: EncryptionKeyDtoPublicKeyUseEnum;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'n': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyDtoPublicKey
     */
    'e': string;
}

export const EncryptionKeyDtoPublicKeyKtyEnum = {
    Rsa: 'RSA'
} as const;

export type EncryptionKeyDtoPublicKeyKtyEnum = typeof EncryptionKeyDtoPublicKeyKtyEnum[keyof typeof EncryptionKeyDtoPublicKeyKtyEnum];
export const EncryptionKeyDtoPublicKeyAlgEnum = {
    Rs256: 'RS256'
} as const;

export type EncryptionKeyDtoPublicKeyAlgEnum = typeof EncryptionKeyDtoPublicKeyAlgEnum[keyof typeof EncryptionKeyDtoPublicKeyAlgEnum];
export const EncryptionKeyDtoPublicKeyUseEnum = {
    Sig: 'sig',
    Enc: 'enc'
} as const;

export type EncryptionKeyDtoPublicKeyUseEnum = typeof EncryptionKeyDtoPublicKeyUseEnum[keyof typeof EncryptionKeyDtoPublicKeyUseEnum];

/**
 * 
 * @export
 * @interface GenerateWalletDto
 */
export interface GenerateWalletDto {
    /**
     * 
     * @type {GenerateWalletDtoCurve}
     * @memberof GenerateWalletDto
     */
    'curve'?: GenerateWalletDtoCurve;
    /**
     * 
     * @type {string}
     * @memberof GenerateWalletDto
     */
    'keyId'?: string;
}
/**
 * @type GenerateWalletDtoCurve
 * @export
 */
export type GenerateWalletDtoCurve = string;

/**
 * 
 * @export
 * @interface ImportPrivateKeyDto
 */
export interface ImportPrivateKeyDto {
    /**
     * Account Private Key, unencrypted
     * @type {any}
     * @memberof ImportPrivateKeyDto
     */
    'privateKey'?: any;
    /**
     * Account Private Key encrypted with JWE. Header MUST include \"kid\"
     * @type {string}
     * @memberof ImportPrivateKeyDto
     */
    'encryptedPrivateKey'?: string;
    /**
     * If not provided, it will be derived as \"eip155:eoa:${address}\"
     * @type {string}
     * @memberof ImportPrivateKeyDto
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface ImportWalletDto
 */
export interface ImportWalletDto {
    /**
     * 
     * @type {string}
     * @memberof ImportWalletDto
     */
    'keyId'?: string;
    /**
     * 
     * @type {GenerateWalletDtoCurve}
     * @memberof ImportWalletDto
     */
    'curve'?: GenerateWalletDtoCurve;
    /**
     * 
     * @type {string}
     * @memberof ImportWalletDto
     */
    'encryptedSeed': string;
}
/**
 * 
 * @export
 * @interface InitiateConnectionDto
 */
export interface InitiateConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof InitiateConnectionDto
     */
    'connectionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InitiateConnectionDto
     */
    'provider': InitiateConnectionDtoProviderEnum;
}

export const InitiateConnectionDtoProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type InitiateConnectionDtoProviderEnum = typeof InitiateConnectionDtoProviderEnum[keyof typeof InitiateConnectionDtoProviderEnum];

/**
 * 
 * @export
 * @interface KnownDestinationDto
 */
export interface KnownDestinationDto {
    /**
     * 
     * @type {PaginatedKnownDestinationsDtoDataInner}
     * @memberof KnownDestinationDto
     */
    'data': PaginatedKnownDestinationsDtoDataInner;
}
/**
 * 
 * @export
 * @interface PaginatedAccountsDto
 */
export interface PaginatedAccountsDto {
    /**
     * 
     * @type {Array<PaginatedWalletsDtoDataInnerAccountsInner>}
     * @memberof PaginatedAccountsDto
     */
    'data': Array<PaginatedWalletsDtoDataInnerAccountsInner>;
    /**
     * 
     * @type {PaginatedConnectionsDtoPage}
     * @memberof PaginatedAccountsDto
     */
    'page'?: PaginatedConnectionsDtoPage;
}
/**
 * 
 * @export
 * @interface PaginatedAddressesDto
 */
export interface PaginatedAddressesDto {
    /**
     * 
     * @type {Array<PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner>}
     * @memberof PaginatedAddressesDto
     */
    'data': Array<PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner>;
    /**
     * 
     * @type {PaginatedConnectionsDtoPage}
     * @memberof PaginatedAddressesDto
     */
    'page'?: PaginatedConnectionsDtoPage;
}
/**
 * 
 * @export
 * @interface PaginatedConnectionsDto
 */
export interface PaginatedConnectionsDto {
    /**
     * 
     * @type {Array<ProviderConnectionDtoData>}
     * @memberof PaginatedConnectionsDto
     */
    'data': Array<ProviderConnectionDtoData>;
    /**
     * 
     * @type {PaginatedConnectionsDtoPage}
     * @memberof PaginatedConnectionsDto
     */
    'page'?: PaginatedConnectionsDtoPage;
}
/**
 * 
 * @export
 * @interface PaginatedConnectionsDtoPage
 */
export interface PaginatedConnectionsDtoPage {
    /**
     * 
     * @type {string}
     * @memberof PaginatedConnectionsDtoPage
     */
    'next': string | null;
}
/**
 * 
 * @export
 * @interface PaginatedKnownDestinationsDto
 */
export interface PaginatedKnownDestinationsDto {
    /**
     * 
     * @type {Array<PaginatedKnownDestinationsDtoDataInner>}
     * @memberof PaginatedKnownDestinationsDto
     */
    'data': Array<PaginatedKnownDestinationsDtoDataInner>;
    /**
     * 
     * @type {PaginatedConnectionsDtoPage}
     * @memberof PaginatedKnownDestinationsDto
     */
    'page'?: PaginatedConnectionsDtoPage;
}
/**
 * 
 * @export
 * @interface PaginatedKnownDestinationsDtoDataInner
 */
export interface PaginatedKnownDestinationsDtoDataInner {
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'knownDestinationId': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'clientId': string;
    /**
     * 
     * @type {Array<ProviderConnectionDtoData>}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'connections': Array<ProviderConnectionDtoData>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'provider': PaginatedKnownDestinationsDtoDataInnerProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'externalId': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'externalClassification'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'assetId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'networkId': string;
    /**
     * 
     * @type {any}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'createdAt': any;
    /**
     * 
     * @type {any}
     * @memberof PaginatedKnownDestinationsDtoDataInner
     */
    'updatedAt': any;
}

export const PaginatedKnownDestinationsDtoDataInnerProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type PaginatedKnownDestinationsDtoDataInnerProviderEnum = typeof PaginatedKnownDestinationsDtoDataInnerProviderEnum[keyof typeof PaginatedKnownDestinationsDtoDataInnerProviderEnum];

/**
 * 
 * @export
 * @interface PaginatedSyncsDto
 */
export interface PaginatedSyncsDto {
    /**
     * 
     * @type {Array<SyncStartedDtoDataSyncsInner>}
     * @memberof PaginatedSyncsDto
     */
    'data': Array<SyncStartedDtoDataSyncsInner>;
    /**
     * 
     * @type {PaginatedConnectionsDtoPage}
     * @memberof PaginatedSyncsDto
     */
    'page'?: PaginatedConnectionsDtoPage;
}
/**
 * 
 * @export
 * @interface PaginatedWalletsDto
 */
export interface PaginatedWalletsDto {
    /**
     * 
     * @type {Array<PaginatedWalletsDtoDataInner>}
     * @memberof PaginatedWalletsDto
     */
    'data': Array<PaginatedWalletsDtoDataInner>;
    /**
     * 
     * @type {PaginatedConnectionsDtoPage}
     * @memberof PaginatedWalletsDto
     */
    'page'?: PaginatedConnectionsDtoPage;
}
/**
 * 
 * @export
 * @interface PaginatedWalletsDtoDataInner
 */
export interface PaginatedWalletsDtoDataInner {
    /**
     * 
     * @type {Array<PaginatedWalletsDtoDataInnerAccountsInner>}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'accounts'?: Array<PaginatedWalletsDtoDataInnerAccountsInner>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'clientId': string;
    /**
     * 
     * @type {Array<ProviderConnectionDtoData>}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'connections': Array<ProviderConnectionDtoData>;
    /**
     * 
     * @type {any}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'createdAt': any;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'externalId': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'provider': PaginatedWalletsDtoDataInnerProviderEnum;
    /**
     * 
     * @type {any}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'updatedAt': any;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInner
     */
    'walletId': string;
}

export const PaginatedWalletsDtoDataInnerProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type PaginatedWalletsDtoDataInnerProviderEnum = typeof PaginatedWalletsDtoDataInnerProviderEnum[keyof typeof PaginatedWalletsDtoDataInnerProviderEnum];

/**
 * 
 * @export
 * @interface PaginatedWalletsDtoDataInnerAccountsInner
 */
export interface PaginatedWalletsDtoDataInnerAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'accountId': string;
    /**
     * 
     * @type {Array<PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner>}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'addresses'?: Array<PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'clientId': string;
    /**
     * 
     * @type {any}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'createdAt': any;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'externalId': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'networkId': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'provider': PaginatedWalletsDtoDataInnerAccountsInnerProviderEnum;
    /**
     * 
     * @type {any}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'updatedAt': any;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInner
     */
    'walletId': string;
}

export const PaginatedWalletsDtoDataInnerAccountsInnerProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type PaginatedWalletsDtoDataInnerAccountsInnerProviderEnum = typeof PaginatedWalletsDtoDataInnerAccountsInnerProviderEnum[keyof typeof PaginatedWalletsDtoDataInnerAccountsInnerProviderEnum];

/**
 * 
 * @export
 * @interface PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
 */
export interface PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner {
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
     */
    'addressId': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
     */
    'clientId': string;
    /**
     * 
     * @type {any}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
     */
    'createdAt': any;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
     */
    'externalId': string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
     */
    'provider': PaginatedWalletsDtoDataInnerAccountsInnerAddressesInnerProviderEnum;
    /**
     * 
     * @type {any}
     * @memberof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInner
     */
    'updatedAt': any;
}

export const PaginatedWalletsDtoDataInnerAccountsInnerAddressesInnerProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type PaginatedWalletsDtoDataInnerAccountsInnerAddressesInnerProviderEnum = typeof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInnerProviderEnum[keyof typeof PaginatedWalletsDtoDataInnerAccountsInnerAddressesInnerProviderEnum];

/**
 * 
 * @export
 * @interface PongDto
 */
export interface PongDto {
    /**
     * 
     * @type {boolean}
     * @memberof PongDto
     */
    'pong': boolean;
}
/**
 * 
 * @export
 * @interface ProviderAccountDto
 */
export interface ProviderAccountDto {
    /**
     * 
     * @type {PaginatedWalletsDtoDataInnerAccountsInner}
     * @memberof ProviderAccountDto
     */
    'data': PaginatedWalletsDtoDataInnerAccountsInner;
}
/**
 * 
 * @export
 * @interface ProviderConnectionDto
 */
export interface ProviderConnectionDto {
    /**
     * 
     * @type {ProviderConnectionDtoData}
     * @memberof ProviderConnectionDto
     */
    'data': ProviderConnectionDtoData;
}
/**
 * @type ProviderConnectionDtoData
 * @export
 */
export type ProviderConnectionDtoData = ProviderConnectionDtoDataOneOf | ProviderConnectionDtoDataOneOf1 | ProviderConnectionDtoDataOneOf2;

/**
 * 
 * @export
 * @interface ProviderConnectionDtoDataOneOf
 */
export interface ProviderConnectionDtoDataOneOf {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'connectionId': string;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'createdAt': any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'provider': ProviderConnectionDtoDataOneOfProviderEnum;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'revokedAt'?: any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'status': ProviderConnectionDtoDataOneOfStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'updatedAt': any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf
     */
    'url': string;
}

export const ProviderConnectionDtoDataOneOfProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type ProviderConnectionDtoDataOneOfProviderEnum = typeof ProviderConnectionDtoDataOneOfProviderEnum[keyof typeof ProviderConnectionDtoDataOneOfProviderEnum];
export const ProviderConnectionDtoDataOneOfStatusEnum = {
    Active: 'active'
} as const;

export type ProviderConnectionDtoDataOneOfStatusEnum = typeof ProviderConnectionDtoDataOneOfStatusEnum[keyof typeof ProviderConnectionDtoDataOneOfStatusEnum];

/**
 * 
 * @export
 * @interface ProviderConnectionDtoDataOneOf1
 */
export interface ProviderConnectionDtoDataOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'connectionId': string;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'createdAt': any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'provider': ProviderConnectionDtoDataOneOf1ProviderEnum;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'revokedAt': any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'status': ProviderConnectionDtoDataOneOf1StatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'updatedAt': any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf1
     */
    'url'?: string;
}

export const ProviderConnectionDtoDataOneOf1ProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type ProviderConnectionDtoDataOneOf1ProviderEnum = typeof ProviderConnectionDtoDataOneOf1ProviderEnum[keyof typeof ProviderConnectionDtoDataOneOf1ProviderEnum];
export const ProviderConnectionDtoDataOneOf1StatusEnum = {
    Revoked: 'revoked'
} as const;

export type ProviderConnectionDtoDataOneOf1StatusEnum = typeof ProviderConnectionDtoDataOneOf1StatusEnum[keyof typeof ProviderConnectionDtoDataOneOf1StatusEnum];

/**
 * 
 * @export
 * @interface ProviderConnectionDtoDataOneOf2
 */
export interface ProviderConnectionDtoDataOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'connectionId': string;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'createdAt': any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'provider': ProviderConnectionDtoDataOneOf2ProviderEnum;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'revokedAt'?: any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'status': ProviderConnectionDtoDataOneOf2StatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'updatedAt': any;
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'url'?: string;
    /**
     * 
     * @type {CreateClientDtoBackupPublicKey}
     * @memberof ProviderConnectionDtoDataOneOf2
     */
    'encryptionPublicKey'?: CreateClientDtoBackupPublicKey;
}

export const ProviderConnectionDtoDataOneOf2ProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type ProviderConnectionDtoDataOneOf2ProviderEnum = typeof ProviderConnectionDtoDataOneOf2ProviderEnum[keyof typeof ProviderConnectionDtoDataOneOf2ProviderEnum];
export const ProviderConnectionDtoDataOneOf2StatusEnum = {
    Pending: 'pending'
} as const;

export type ProviderConnectionDtoDataOneOf2StatusEnum = typeof ProviderConnectionDtoDataOneOf2StatusEnum[keyof typeof ProviderConnectionDtoDataOneOf2StatusEnum];

/**
 * 
 * @export
 * @interface ProviderPendingConnectionDto
 */
export interface ProviderPendingConnectionDto {
    /**
     * 
     * @type {ProviderPendingConnectionDtoData}
     * @memberof ProviderPendingConnectionDto
     */
    'data': ProviderPendingConnectionDtoData;
}
/**
 * 
 * @export
 * @interface ProviderPendingConnectionDtoData
 */
export interface ProviderPendingConnectionDtoData {
    /**
     * 
     * @type {string}
     * @memberof ProviderPendingConnectionDtoData
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof ProviderPendingConnectionDtoData
     */
    'connectionId': string;
    /**
     * 
     * @type {string}
     * @memberof ProviderPendingConnectionDtoData
     */
    'provider': ProviderPendingConnectionDtoDataProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof ProviderPendingConnectionDtoData
     */
    'status': ProviderPendingConnectionDtoDataStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof ProviderPendingConnectionDtoData
     */
    'createdAt': any;
    /**
     * 
     * @type {ProviderPendingConnectionDtoDataPublicKey}
     * @memberof ProviderPendingConnectionDtoData
     */
    'publicKey'?: ProviderPendingConnectionDtoDataPublicKey;
    /**
     * 
     * @type {EncryptionKeyDtoData}
     * @memberof ProviderPendingConnectionDtoData
     */
    'encryptionPublicKey': EncryptionKeyDtoData;
}

export const ProviderPendingConnectionDtoDataProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type ProviderPendingConnectionDtoDataProviderEnum = typeof ProviderPendingConnectionDtoDataProviderEnum[keyof typeof ProviderPendingConnectionDtoDataProviderEnum];
export const ProviderPendingConnectionDtoDataStatusEnum = {
    Pending: 'pending'
} as const;

export type ProviderPendingConnectionDtoDataStatusEnum = typeof ProviderPendingConnectionDtoDataStatusEnum[keyof typeof ProviderPendingConnectionDtoDataStatusEnum];

/**
 * 
 * @export
 * @interface ProviderPendingConnectionDtoDataPublicKey
 */
export interface ProviderPendingConnectionDtoDataPublicKey {
    /**
     * 
     * @type {string}
     * @memberof ProviderPendingConnectionDtoDataPublicKey
     */
    'keyId'?: string;
    /**
     * 
     * @type {CreateClientDtoAuthLocalAllowedUsersInnerPublicKey}
     * @memberof ProviderPendingConnectionDtoDataPublicKey
     */
    'jwk'?: CreateClientDtoAuthLocalAllowedUsersInnerPublicKey;
    /**
     * 
     * @type {any}
     * @memberof ProviderPendingConnectionDtoDataPublicKey
     */
    'hex'?: any;
}
/**
 * 
 * @export
 * @interface ProviderWalletDto
 */
export interface ProviderWalletDto {
    /**
     * 
     * @type {PaginatedWalletsDtoDataInner}
     * @memberof ProviderWalletDto
     */
    'data': PaginatedWalletsDtoDataInner;
}
/**
 * 
 * @export
 * @interface SendTransferDto
 */
export interface SendTransferDto {
    /**
     * 
     * @type {SendTransferDtoSource}
     * @memberof SendTransferDto
     */
    'source': SendTransferDtoSource;
    /**
     * 
     * @type {SendTransferDtoDestination}
     * @memberof SendTransferDto
     */
    'destination': SendTransferDtoDestination;
    /**
     * 
     * @type {string}
     * @memberof SendTransferDto
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof SendTransferDto
     */
    'assetId': string;
    /**
     * 
     * @type {string}
     * @memberof SendTransferDto
     */
    'networkFeeAttribution'?: SendTransferDtoNetworkFeeAttributionEnum;
    /**
     * 
     * @type {string}
     * @memberof SendTransferDto
     */
    'customerRefId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SendTransferDto
     */
    'idempotenceId': string;
    /**
     * 
     * @type {string}
     * @memberof SendTransferDto
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof SendTransferDto
     */
    'provider'?: SendTransferDtoProviderEnum;
    /**
     * 
     * @type {any}
     * @memberof SendTransferDto
     */
    'providerSpecific'?: any;
}

export const SendTransferDtoNetworkFeeAttributionEnum = {
    OnTop: 'on_top',
    Deduct: 'deduct'
} as const;

export type SendTransferDtoNetworkFeeAttributionEnum = typeof SendTransferDtoNetworkFeeAttributionEnum[keyof typeof SendTransferDtoNetworkFeeAttributionEnum];
export const SendTransferDtoProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type SendTransferDtoProviderEnum = typeof SendTransferDtoProviderEnum[keyof typeof SendTransferDtoProviderEnum];

/**
 * @type SendTransferDtoDestination
 * @export
 */
export type SendTransferDtoDestination = SendTransferDtoDestinationOneOf | SendTransferDtoSource;

/**
 * 
 * @export
 * @interface SendTransferDtoDestinationOneOf
 */
export interface SendTransferDtoDestinationOneOf {
    /**
     * 
     * @type {string}
     * @memberof SendTransferDtoDestinationOneOf
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface SendTransferDtoSource
 */
export interface SendTransferDtoSource {
    /**
     * 
     * @type {string}
     * @memberof SendTransferDtoSource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SendTransferDtoSource
     */
    'type': SendTransferDtoSourceTypeEnum;
}

export const SendTransferDtoSourceTypeEnum = {
    Wallet: 'wallet',
    Account: 'account',
    Address: 'address'
} as const;

export type SendTransferDtoSourceTypeEnum = typeof SendTransferDtoSourceTypeEnum[keyof typeof SendTransferDtoSourceTypeEnum];

/**
 * 
 * @export
 * @interface SignRequestDto
 */
export interface SignRequestDto {
    /**
     * 
     * @type {SignRequestDtoRequest}
     * @memberof SignRequestDto
     */
    'request': SignRequestDtoRequest;
}
/**
 * @type SignRequestDtoRequest
 * @export
 */
export type SignRequestDtoRequest = SignRequestDtoRequestOneOf | SignRequestDtoRequestOneOf1 | SignRequestDtoRequestOneOf2 | SignRequestDtoRequestOneOf3 | SignRequestDtoRequestOneOf4;

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf
 */
export interface SignRequestDtoRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'action': SignRequestDtoRequestOneOfActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOfTransactionRequest}
     * @memberof SignRequestDtoRequestOneOf
     */
    'transactionRequest': SignRequestDtoRequestOneOfTransactionRequest;
}

export const SignRequestDtoRequestOneOfActionEnum = {
    SignTransaction: 'signTransaction'
} as const;

export type SignRequestDtoRequestOneOfActionEnum = typeof SignRequestDtoRequestOneOfActionEnum[keyof typeof SignRequestDtoRequestOneOfActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf1
 */
export interface SignRequestDtoRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'action': SignRequestDtoRequestOneOf1ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOf1Message}
     * @memberof SignRequestDtoRequestOneOf1
     */
    'message': SignRequestDtoRequestOneOf1Message;
}

export const SignRequestDtoRequestOneOf1ActionEnum = {
    SignMessage: 'signMessage'
} as const;

export type SignRequestDtoRequestOneOf1ActionEnum = typeof SignRequestDtoRequestOneOf1ActionEnum[keyof typeof SignRequestDtoRequestOneOf1ActionEnum];

/**
 * @type SignRequestDtoRequestOneOf1Message
 * @export
 */
export type SignRequestDtoRequestOneOf1Message = SignRequestDtoRequestOneOf1MessageOneOf | string;

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf1MessageOneOf
 */
export interface SignRequestDtoRequestOneOf1MessageOneOf {
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf1MessageOneOf
     */
    'raw': any;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2
 */
export interface SignRequestDtoRequestOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'action': SignRequestDtoRequestOneOf2ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOf2TypedData}
     * @memberof SignRequestDtoRequestOneOf2
     */
    'typedData': SignRequestDtoRequestOneOf2TypedData;
}

export const SignRequestDtoRequestOneOf2ActionEnum = {
    SignTypedData: 'signTypedData'
} as const;

export type SignRequestDtoRequestOneOf2ActionEnum = typeof SignRequestDtoRequestOneOf2ActionEnum[keyof typeof SignRequestDtoRequestOneOf2ActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedData
 */
export interface SignRequestDtoRequestOneOf2TypedData {
    /**
     * 
     * @type {SignRequestDtoRequestOneOf2TypedDataDomain}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'domain': SignRequestDtoRequestOneOf2TypedDataDomain;
    /**
     * 
     * @type {{ [key: string]: Array<SignRequestDtoRequestOneOf2TypedDataTypesValueInner>; }}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'types': { [key: string]: Array<SignRequestDtoRequestOneOf2TypedDataTypesValueInner>; };
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'primaryType': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SignRequestDtoRequestOneOf2TypedData
     */
    'message': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedDataDomain
 */
export interface SignRequestDtoRequestOneOf2TypedDataDomain {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'version'?: string;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'chainId'?: number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'verifyingContract'?: any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf2TypedDataDomain
     */
    'salt'?: any;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf2TypedDataTypesValueInner
 */
export interface SignRequestDtoRequestOneOf2TypedDataTypesValueInner {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataTypesValueInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf2TypedDataTypesValueInner
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf3
 */
export interface SignRequestDtoRequestOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'action': SignRequestDtoRequestOneOf3ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'resourceId': string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf3
     */
    'rawMessage': any;
}

export const SignRequestDtoRequestOneOf3ActionEnum = {
    SignRaw: 'signRaw'
} as const;

export type SignRequestDtoRequestOneOf3ActionEnum = typeof SignRequestDtoRequestOneOf3ActionEnum[keyof typeof SignRequestDtoRequestOneOf3ActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf4
 */
export interface SignRequestDtoRequestOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4
     */
    'action': SignRequestDtoRequestOneOf4ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4
     */
    'resourceId': string;
    /**
     * 
     * @type {SignRequestDtoRequestOneOf4UserOperation}
     * @memberof SignRequestDtoRequestOneOf4
     */
    'userOperation': SignRequestDtoRequestOneOf4UserOperation;
}

export const SignRequestDtoRequestOneOf4ActionEnum = {
    SignUserOperation: 'signUserOperation'
} as const;

export type SignRequestDtoRequestOneOf4ActionEnum = typeof SignRequestDtoRequestOneOf4ActionEnum[keyof typeof SignRequestDtoRequestOneOf4ActionEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOf4UserOperation
 */
export interface SignRequestDtoRequestOneOf4UserOperation {
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'sender': any;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'nonce': string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'initCode': any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'callData': any;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'callGasLimit': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'verificationGasLimit': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'preVerificationGas': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'maxFeePerGas': string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'maxPriorityFeePerGas': string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'paymasterAndData': any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'entryPoint': any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'signature': any;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'factoryAddress': any;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOf4UserOperation
     */
    'chainId': number;
}
/**
 * @type SignRequestDtoRequestOneOfTransactionRequest
 * @export
 */
export type SignRequestDtoRequestOneOfTransactionRequest = SignRequestDtoRequestOneOfTransactionRequestOneOf | SignRequestDtoRequestOneOfTransactionRequestOneOf1;

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOfTransactionRequestOneOf
 */
export interface SignRequestDtoRequestOneOfTransactionRequestOneOf {
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'chainId': number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'from': any;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'nonce'?: number;
    /**
     * 
     * @type {Array<SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner>}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'accessList'?: Array<SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner>;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'gas'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'maxFeePerGas'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'maxPriorityFeePerGas'?: string;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'to'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'type'?: SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf
     */
    'value'?: any;
}

export const SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum = {
    _2: '2'
} as const;

export type SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum = typeof SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum[keyof typeof SignRequestDtoRequestOneOfTransactionRequestOneOfTypeEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOfTransactionRequestOneOf1
 */
export interface SignRequestDtoRequestOneOfTransactionRequestOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'chainId': number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'from': any;
    /**
     * 
     * @type {number}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'nonce'?: number;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'gas'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'gasPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'type'?: SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'to'?: any | null;
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOf1
     */
    'value'?: any;
}

export const SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum = {
    _0: '0'
} as const;

export type SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum = typeof SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum[keyof typeof SignRequestDtoRequestOneOfTransactionRequestOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner
 */
export interface SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner {
    /**
     * 
     * @type {any}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner
     */
    'address': any;
    /**
     * 
     * @type {Array<any>}
     * @memberof SignRequestDtoRequestOneOfTransactionRequestOneOfAccessListInner
     */
    'storageKeys': Array<any>;
}
/**
 * 
 * @export
 * @interface SignatureDto
 */
export interface SignatureDto {
    /**
     * 
     * @type {any}
     * @memberof SignatureDto
     */
    'signature': any;
}
/**
 * 
 * @export
 * @interface StartSyncDto
 */
export interface StartSyncDto {
    /**
     * The connection to sync. If undefined, start the sync on all active connections
     * @type {string}
     * @memberof StartSyncDto
     */
    'connectionId'?: string;
}
/**
 * 
 * @export
 * @interface SyncDto
 */
export interface SyncDto {
    /**
     * 
     * @type {SyncStartedDtoDataSyncsInner}
     * @memberof SyncDto
     */
    'data': SyncStartedDtoDataSyncsInner;
}
/**
 * 
 * @export
 * @interface SyncStartedDto
 */
export interface SyncStartedDto {
    /**
     * 
     * @type {SyncStartedDtoData}
     * @memberof SyncStartedDto
     */
    'data': SyncStartedDtoData;
}
/**
 * 
 * @export
 * @interface SyncStartedDtoData
 */
export interface SyncStartedDtoData {
    /**
     * 
     * @type {boolean}
     * @memberof SyncStartedDtoData
     */
    'started': boolean;
    /**
     * 
     * @type {Array<SyncStartedDtoDataSyncsInner>}
     * @memberof SyncStartedDtoData
     */
    'syncs': Array<SyncStartedDtoDataSyncsInner>;
}
/**
 * 
 * @export
 * @interface SyncStartedDtoDataSyncsInner
 */
export interface SyncStartedDtoDataSyncsInner {
    /**
     * 
     * @type {string}
     * @memberof SyncStartedDtoDataSyncsInner
     */
    'clientId': string;
    /**
     * 
     * @type {any}
     * @memberof SyncStartedDtoDataSyncsInner
     */
    'completedAt'?: any;
    /**
     * 
     * @type {string}
     * @memberof SyncStartedDtoDataSyncsInner
     */
    'connectionId': string;
    /**
     * 
     * @type {any}
     * @memberof SyncStartedDtoDataSyncsInner
     */
    'createdAt': any;
    /**
     * 
     * @type {SyncStartedDtoDataSyncsInnerError}
     * @memberof SyncStartedDtoDataSyncsInner
     */
    'error'?: SyncStartedDtoDataSyncsInnerError;
    /**
     * 
     * @type {string}
     * @memberof SyncStartedDtoDataSyncsInner
     */
    'status'?: SyncStartedDtoDataSyncsInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SyncStartedDtoDataSyncsInner
     */
    'syncId': string;
}

export const SyncStartedDtoDataSyncsInnerStatusEnum = {
    Processing: 'processing',
    Success: 'success',
    Failed: 'failed'
} as const;

export type SyncStartedDtoDataSyncsInnerStatusEnum = typeof SyncStartedDtoDataSyncsInnerStatusEnum[keyof typeof SyncStartedDtoDataSyncsInnerStatusEnum];

/**
 * 
 * @export
 * @interface SyncStartedDtoDataSyncsInnerError
 */
export interface SyncStartedDtoDataSyncsInnerError {
    /**
     * 
     * @type {string}
     * @memberof SyncStartedDtoDataSyncsInnerError
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncStartedDtoDataSyncsInnerError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncStartedDtoDataSyncsInnerError
     */
    'traceId'?: string;
}
/**
 * 
 * @export
 * @interface TransferDto
 */
export interface TransferDto {
    /**
     * 
     * @type {TransferDtoData}
     * @memberof TransferDto
     */
    'data': TransferDtoData;
}
/**
 * 
 * @export
 * @interface TransferDtoData
 */
export interface TransferDtoData {
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'assetId': string;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'clientId': string;
    /**
     * 
     * @type {any}
     * @memberof TransferDtoData
     */
    'createdAt': any;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'customerRefId': string | null;
    /**
     * 
     * @type {SendTransferDtoDestination}
     * @memberof TransferDtoData
     */
    'destination': SendTransferDtoDestination;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'externalId': string;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'grossAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'idempotenceId': string | null;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'memo': string | null;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'networkFeeAttribution': TransferDtoDataNetworkFeeAttributionEnum;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'provider': TransferDtoDataProviderEnum;
    /**
     * 
     * @type {any}
     * @memberof TransferDtoData
     */
    'providerSpecific': any | null;
    /**
     * 
     * @type {SendTransferDtoSource}
     * @memberof TransferDtoData
     */
    'source': SendTransferDtoSource;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'status'?: TransferDtoDataStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TransferDtoData
     */
    'transferId': string;
}

export const TransferDtoDataNetworkFeeAttributionEnum = {
    OnTop: 'on_top',
    Deduct: 'deduct'
} as const;

export type TransferDtoDataNetworkFeeAttributionEnum = typeof TransferDtoDataNetworkFeeAttributionEnum[keyof typeof TransferDtoDataNetworkFeeAttributionEnum];
export const TransferDtoDataProviderEnum = {
    Anchorage: 'anchorage',
    Fireblocks: 'fireblocks'
} as const;

export type TransferDtoDataProviderEnum = typeof TransferDtoDataProviderEnum[keyof typeof TransferDtoDataProviderEnum];
export const TransferDtoDataStatusEnum = {
    Processing: 'processing',
    Success: 'success',
    Failed: 'failed'
} as const;

export type TransferDtoDataStatusEnum = typeof TransferDtoDataStatusEnum[keyof typeof TransferDtoDataStatusEnum];

/**
 * 
 * @export
 * @interface UpdateConnectionDto
 */
export interface UpdateConnectionDto {
    /**
     * 
     * @type {any}
     * @memberof UpdateConnectionDto
     */
    'credentials'?: any | null;
    /**
     * RSA encrypted JSON string of the credentials
     * @type {string}
     * @memberof UpdateConnectionDto
     */
    'encryptedCredentials'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateConnectionDto
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateConnectionDto
     */
    'status'?: UpdateConnectionDtoStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof UpdateConnectionDto
     */
    'updatedAt'?: any;
    /**
     * 
     * @type {string}
     * @memberof UpdateConnectionDto
     */
    'url'?: string;
}

export const UpdateConnectionDtoStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Revoked: 'revoked'
} as const;

export type UpdateConnectionDtoStatusEnum = typeof UpdateConnectionDtoStatusEnum[keyof typeof UpdateConnectionDtoStatusEnum];

/**
 * 
 * @export
 * @interface WalletDto
 */
export interface WalletDto {
    /**
     * 
     * @type {WalletDtoAccount}
     * @memberof WalletDto
     */
    'account': WalletDtoAccount;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    'backup'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    'keyId': string;
}
/**
 * 
 * @export
 * @interface WalletDtoAccount
 */
export interface WalletDtoAccount {
    /**
     * 
     * @type {string}
     * @memberof WalletDtoAccount
     */
    'id': string;
    /**
     * 
     * @type {any}
     * @memberof WalletDtoAccount
     */
    'publicKey': any;
    /**
     * 
     * @type {any}
     * @memberof WalletDtoAccount
     */
    'address': any;
    /**
     * 
     * @type {WalletsDtoWalletsInnerOrigin}
     * @memberof WalletDtoAccount
     */
    'origin': WalletsDtoWalletsInnerOrigin;
    /**
     * 
     * @type {string}
     * @memberof WalletDtoAccount
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDtoAccount
     */
    'derivationPath'?: string;
}
/**
 * 
 * @export
 * @interface WalletsDto
 */
export interface WalletsDto {
    /**
     * 
     * @type {Array<WalletsDtoWalletsInner>}
     * @memberof WalletsDto
     */
    'wallets': Array<WalletsDtoWalletsInner>;
}
/**
 * 
 * @export
 * @interface WalletsDtoWalletsInner
 */
export interface WalletsDtoWalletsInner {
    /**
     * 
     * @type {string}
     * @memberof WalletsDtoWalletsInner
     */
    'keyId': string;
    /**
     * 
     * @type {string}
     * @memberof WalletsDtoWalletsInner
     */
    'curve': string;
    /**
     * 
     * @type {WalletsDtoWalletsInnerKeyType}
     * @memberof WalletsDtoWalletsInner
     */
    'keyType': WalletsDtoWalletsInnerKeyType;
    /**
     * 
     * @type {WalletsDtoWalletsInnerOrigin}
     * @memberof WalletsDtoWalletsInner
     */
    'origin': WalletsDtoWalletsInnerOrigin;
}
/**
 * @type WalletsDtoWalletsInnerKeyType
 * @export
 */
export type WalletsDtoWalletsInnerKeyType = string;

/**
 * @type WalletsDtoWalletsInnerOrigin
 * @export
 */
export type WalletsDtoWalletsInnerOrigin = string;


/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {string} xClientId 
         * @param {DeriveAccountDto} deriveAccountDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derive: async (xClientId: string, deriveAccountDto: DeriveAccountDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('derive', 'xClientId', xClientId)
            // verify required parameter 'deriveAccountDto' is not null or undefined
            assertParamExists('derive', 'deriveAccountDto', deriveAccountDto)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deriveAccountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports an account
         * @param {string} xClientId 
         * @param {ImportPrivateKeyDto} importPrivateKeyDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPrivateKey: async (xClientId: string, importPrivateKeyDto: ImportPrivateKeyDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('importPrivateKey', 'xClientId', xClientId)
            // verify required parameter 'importPrivateKeyDto' is not null or undefined
            assertParamExists('importPrivateKey', 'importPrivateKeyDto', importPrivateKeyDto)
            const localVarPath = `/v1/accounts/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importPrivateKeyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {string} xClientId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {string} xClientId 
         * @param {DeriveAccountDto} deriveAccountDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async derive(xClientId: string, deriveAccountDto: DeriveAccountDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeriveAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.derive(xClientId, deriveAccountDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.derive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Imports an account
         * @param {string} xClientId 
         * @param {ImportPrivateKeyDto} importPrivateKeyDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importPrivateKey(xClientId: string, importPrivateKeyDto: ImportPrivateKeyDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importPrivateKey(xClientId, importPrivateKeyDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.importPrivateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {string} xClientId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new account to a wallet
         * @param {AccountApiDeriveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        derive(requestParameters: AccountApiDeriveRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeriveAccountResponseDto> {
            return localVarFp.derive(requestParameters.xClientId, requestParameters.deriveAccountDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Imports an account
         * @param {AccountApiImportPrivateKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPrivateKey(requestParameters: AccountApiImportPrivateKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountDto> {
            return localVarFp.importPrivateKey(requestParameters.xClientId, requestParameters.importPrivateKeyDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists the client accounts
         * @param {AccountApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: AccountApiListRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDto> {
            return localVarFp.list(requestParameters.xClientId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for derive operation in AccountApi.
 * @export
 * @interface AccountApiDeriveRequest
 */
export interface AccountApiDeriveRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiDerive
     */
    readonly xClientId: string

    /**
     * 
     * @type {DeriveAccountDto}
     * @memberof AccountApiDerive
     */
    readonly deriveAccountDto: DeriveAccountDto

    /**
     * 
     * @type {string}
     * @memberof AccountApiDerive
     */
    readonly authorization?: string
}

/**
 * Request parameters for importPrivateKey operation in AccountApi.
 * @export
 * @interface AccountApiImportPrivateKeyRequest
 */
export interface AccountApiImportPrivateKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiImportPrivateKey
     */
    readonly xClientId: string

    /**
     * 
     * @type {ImportPrivateKeyDto}
     * @memberof AccountApiImportPrivateKey
     */
    readonly importPrivateKeyDto: ImportPrivateKeyDto

    /**
     * 
     * @type {string}
     * @memberof AccountApiImportPrivateKey
     */
    readonly authorization?: string
}

/**
 * Request parameters for list operation in AccountApi.
 * @export
 * @interface AccountApiListRequest
 */
export interface AccountApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiList
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof AccountApiList
     */
    readonly authorization?: string
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Add a new account to a wallet
     * @param {AccountApiDeriveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public derive(requestParameters: AccountApiDeriveRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).derive(requestParameters.xClientId, requestParameters.deriveAccountDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Imports an account
     * @param {AccountApiImportPrivateKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public importPrivateKey(requestParameters: AccountApiImportPrivateKeyRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).importPrivateKey(requestParameters.xClientId, requestParameters.importPrivateKeyDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists the client accounts
     * @param {AccountApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public list(requestParameters: AccountApiListRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).list(requestParameters.xClientId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PongDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: RawAxiosRequestConfig): AxiosPromise<PongDto> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {string} xApiKey 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (xApiKey: string, createClientDto: CreateClientDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('create', 'xApiKey', xApiKey)
            // verify required parameter 'createClientDto' is not null or undefined
            assertParamExists('create', 'createClientDto', createClientDto)
            const localVarPath = `/v1/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin-API-Key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClientDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {string} xApiKey 
         * @param {CreateClientDto} createClientDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(xApiKey: string, createClientDto: CreateClientDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(xApiKey, createClientDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new client
         * @param {ClientApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ClientApiCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClientDto> {
            return localVarFp.create(requestParameters.xApiKey, requestParameters.createClientDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in ClientApi.
 * @export
 * @interface ClientApiCreateRequest
 */
export interface ClientApiCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientApiCreate
     */
    readonly xApiKey: string

    /**
     * 
     * @type {CreateClientDto}
     * @memberof ClientApiCreate
     */
    readonly createClientDto: CreateClientDto
}

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new client
     * @param {ClientApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public create(requestParameters: ClientApiCreateRequest, options?: RawAxiosRequestConfig) {
        return ClientApiFp(this.configuration).create(requestParameters.xApiKey, requestParameters.createClientDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EncryptionKeyApi - axios parameter creator
 * @export
 */
export const EncryptionKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {string} xClientId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (xClientId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generate', 'xClientId', xClientId)
            const localVarPath = `/v1/encryption-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EncryptionKeyApi - functional programming interface
 * @export
 */
export const EncryptionKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EncryptionKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {string} xClientId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(xClientId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncryptionKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(xClientId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EncryptionKeyApi.generate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EncryptionKeyApi - factory interface
 * @export
 */
export const EncryptionKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EncryptionKeyApiFp(configuration)
    return {
        /**
         * 
         * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
         * @param {EncryptionKeyApiGenerateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(requestParameters: EncryptionKeyApiGenerateRequest, options?: RawAxiosRequestConfig): AxiosPromise<EncryptionKeyDto> {
            return localVarFp.generate(requestParameters.xClientId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for generate operation in EncryptionKeyApi.
 * @export
 * @interface EncryptionKeyApiGenerateRequest
 */
export interface EncryptionKeyApiGenerateRequest {
    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyApiGenerate
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof EncryptionKeyApiGenerate
     */
    readonly authorization?: string
}

/**
 * EncryptionKeyApi - object-oriented interface
 * @export
 * @class EncryptionKeyApi
 * @extends {BaseAPI}
 */
export class EncryptionKeyApi extends BaseAPI {
    /**
     * 
     * @summary Generates an encryption key pair used to secure end-to-end communication containing sensitive information
     * @param {EncryptionKeyApiGenerateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncryptionKeyApi
     */
    public generate(requestParameters: EncryptionKeyApiGenerateRequest, options?: RawAxiosRequestConfig) {
        return EncryptionKeyApiFp(this.configuration).generate(requestParameters.xClientId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderAccountApi - axios parameter creator
 * @export
 */
export const ProviderAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a specific account by ID
         * @param {string} xClientId 
         * @param {string} accountId The ID of the account to retrieve
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (xClientId: string, accountId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getById', 'xClientId', xClientId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getById', 'accountId', accountId)
            const localVarPath = `/v1/provider/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the client accounts
         * @param {string} xClientId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            const localVarPath = `/v1/provider/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List addresses for a specific account
         * @param {string} xClientId 
         * @param {string} accountId The ID of the account to retrieve addresses for
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses: async (xClientId: string, accountId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('listAddresses', 'xClientId', xClientId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAddresses', 'accountId', accountId)
            const localVarPath = `/v1/provider/accounts/{accountId}/addresses`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderAccountApi - functional programming interface
 * @export
 */
export const ProviderAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a specific account by ID
         * @param {string} xClientId 
         * @param {string} accountId The ID of the account to retrieve
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(xClientId: string, accountId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(xClientId, accountId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderAccountApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the client accounts
         * @param {string} xClientId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderAccountApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List addresses for a specific account
         * @param {string} xClientId 
         * @param {string} accountId The ID of the account to retrieve addresses for
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddresses(xClientId: string, accountId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAddressesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(xClientId, accountId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderAccountApi.listAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderAccountApi - factory interface
 * @export
 */
export const ProviderAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderAccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a specific account by ID
         * @param {ProviderAccountApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ProviderAccountApiGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProviderAccountDto> {
            return localVarFp.getById(requestParameters.xClientId, requestParameters.accountId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the client accounts
         * @param {ProviderAccountApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ProviderAccountApiListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccountsDto> {
            return localVarFp.list(requestParameters.xClientId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List addresses for a specific account
         * @param {ProviderAccountApiListAddressesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses(requestParameters: ProviderAccountApiListAddressesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAddressesDto> {
            return localVarFp.listAddresses(requestParameters.xClientId, requestParameters.accountId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getById operation in ProviderAccountApi.
 * @export
 * @interface ProviderAccountApiGetByIdRequest
 */
export interface ProviderAccountApiGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderAccountApiGetById
     */
    readonly xClientId: string

    /**
     * The ID of the account to retrieve
     * @type {string}
     * @memberof ProviderAccountApiGetById
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderAccountApiGetById
     */
    readonly authorization?: string
}

/**
 * Request parameters for list operation in ProviderAccountApi.
 * @export
 * @interface ProviderAccountApiListRequest
 */
export interface ProviderAccountApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderAccountApiList
     */
    readonly xClientId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderAccountApiList
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderAccountApiList
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderAccountApiList
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderAccountApiList
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderAccountApiList
     */
    readonly authorization?: string
}

/**
 * Request parameters for listAddresses operation in ProviderAccountApi.
 * @export
 * @interface ProviderAccountApiListAddressesRequest
 */
export interface ProviderAccountApiListAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderAccountApiListAddresses
     */
    readonly xClientId: string

    /**
     * The ID of the account to retrieve addresses for
     * @type {string}
     * @memberof ProviderAccountApiListAddresses
     */
    readonly accountId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderAccountApiListAddresses
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderAccountApiListAddresses
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderAccountApiListAddresses
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderAccountApiListAddresses
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderAccountApiListAddresses
     */
    readonly authorization?: string
}

/**
 * ProviderAccountApi - object-oriented interface
 * @export
 * @class ProviderAccountApi
 * @extends {BaseAPI}
 */
export class ProviderAccountApi extends BaseAPI {
    /**
     * 
     * @summary Get a specific account by ID
     * @param {ProviderAccountApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountApi
     */
    public getById(requestParameters: ProviderAccountApiGetByIdRequest, options?: RawAxiosRequestConfig) {
        return ProviderAccountApiFp(this.configuration).getById(requestParameters.xClientId, requestParameters.accountId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the client accounts
     * @param {ProviderAccountApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountApi
     */
    public list(requestParameters: ProviderAccountApiListRequest, options?: RawAxiosRequestConfig) {
        return ProviderAccountApiFp(this.configuration).list(requestParameters.xClientId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List addresses for a specific account
     * @param {ProviderAccountApiListAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountApi
     */
    public listAddresses(requestParameters: ProviderAccountApiListAddressesRequest, options?: RawAxiosRequestConfig) {
        return ProviderAccountApiFp(this.configuration).listAddresses(requestParameters.xClientId, requestParameters.accountId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderAddressApi - axios parameter creator
 * @export
 */
export const ProviderAddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a specific address by ID
         * @param {string} xClientId 
         * @param {string} addressId The ID of the address to retrieve
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (xClientId: string, addressId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getById', 'xClientId', xClientId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getById', 'addressId', addressId)
            const localVarPath = `/v1/provider/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the client addresss
         * @param {string} xClientId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            const localVarPath = `/v1/provider/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderAddressApi - functional programming interface
 * @export
 */
export const ProviderAddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderAddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a specific address by ID
         * @param {string} xClientId 
         * @param {string} addressId The ID of the address to retrieve
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(xClientId: string, addressId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAddressesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(xClientId, addressId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderAddressApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the client addresss
         * @param {string} xClientId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAddressesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderAddressApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderAddressApi - factory interface
 * @export
 */
export const ProviderAddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderAddressApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a specific address by ID
         * @param {ProviderAddressApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ProviderAddressApiGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAddressesDto> {
            return localVarFp.getById(requestParameters.xClientId, requestParameters.addressId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the client addresss
         * @param {ProviderAddressApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ProviderAddressApiListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAddressesDto> {
            return localVarFp.list(requestParameters.xClientId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getById operation in ProviderAddressApi.
 * @export
 * @interface ProviderAddressApiGetByIdRequest
 */
export interface ProviderAddressApiGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderAddressApiGetById
     */
    readonly xClientId: string

    /**
     * The ID of the address to retrieve
     * @type {string}
     * @memberof ProviderAddressApiGetById
     */
    readonly addressId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderAddressApiGetById
     */
    readonly authorization?: string
}

/**
 * Request parameters for list operation in ProviderAddressApi.
 * @export
 * @interface ProviderAddressApiListRequest
 */
export interface ProviderAddressApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderAddressApiList
     */
    readonly xClientId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderAddressApiList
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderAddressApiList
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderAddressApiList
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderAddressApiList
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderAddressApiList
     */
    readonly authorization?: string
}

/**
 * ProviderAddressApi - object-oriented interface
 * @export
 * @class ProviderAddressApi
 * @extends {BaseAPI}
 */
export class ProviderAddressApi extends BaseAPI {
    /**
     * 
     * @summary Get a specific address by ID
     * @param {ProviderAddressApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAddressApi
     */
    public getById(requestParameters: ProviderAddressApiGetByIdRequest, options?: RawAxiosRequestConfig) {
        return ProviderAddressApiFp(this.configuration).getById(requestParameters.xClientId, requestParameters.addressId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the client addresss
     * @param {ProviderAddressApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAddressApi
     */
    public list(requestParameters: ProviderAddressApiListRequest, options?: RawAxiosRequestConfig) {
        return ProviderAddressApiFp(this.configuration).list(requestParameters.xClientId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderConnectionApi - axios parameter creator
 * @export
 */
export const ProviderConnectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint securely stores the details of a provider connection, ensuring that all sensitive information is encrypted.
         * @summary Store a provider connection securely
         * @param {string} xClientId 
         * @param {CreateConnectionDto} createConnectionDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (xClientId: string, createConnectionDto: CreateConnectionDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('create', 'xClientId', xClientId)
            // verify required parameter 'createConnectionDto' is not null or undefined
            assertParamExists('create', 'createConnectionDto', createConnectionDto)
            const localVarPath = `/v1/provider/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves the details of a specific connection associated with the client, identified by the ID.
         * @summary Retrieve a specific connection by ID
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (xClientId: string, connectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getById', 'xClientId', xClientId)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getById', 'connectionId', connectionId)
            const localVarPath = `/v1/provider/connections/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint initiates a new connection by generating a public key and an encryption key for secure communication.
         * @summary Initiate a new provider connection
         * @param {string} xClientId 
         * @param {InitiateConnectionDto} initiateConnectionDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiate: async (xClientId: string, initiateConnectionDto: InitiateConnectionDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('initiate', 'xClientId', xClientId)
            // verify required parameter 'initiateConnectionDto' is not null or undefined
            assertParamExists('initiate', 'initiateConnectionDto', initiateConnectionDto)
            const localVarPath = `/v1/provider/connections/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of all connections associated with the client.
         * @summary List all connections
         * @param {string} xClientId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            const localVarPath = `/v1/provider/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of accounts associated with a specific connection.
         * @summary List accounts for a specific connection
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (xClientId: string, connectionId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('listAccounts', 'xClientId', xClientId)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('listAccounts', 'connectionId', connectionId)
            const localVarPath = `/v1/provider/connections/{connectionId}/accounts`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of wallets associated with a specific connection.
         * @summary List wallets for a specific connection
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets: async (xClientId: string, connectionId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('listWallets', 'xClientId', xClientId)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('listWallets', 'connectionId', connectionId)
            const localVarPath = `/v1/provider/connections/{connectionId}/wallets`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint revokes an existing connection, effectively terminating any ongoing communication and invalidating the connection credentials.
         * @summary Revoke an existing connection
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revoke: async (xClientId: string, connectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('revoke', 'xClientId', xClientId)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('revoke', 'connectionId', connectionId)
            const localVarPath = `/v1/provider/connections/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the details of a specific connection associated with the client, identified by the connection ID.
         * @summary Update a specific connection by ID
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {UpdateConnectionDto} updateConnectionDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (xClientId: string, connectionId: string, updateConnectionDto: UpdateConnectionDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('update', 'xClientId', xClientId)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('update', 'connectionId', connectionId)
            // verify required parameter 'updateConnectionDto' is not null or undefined
            assertParamExists('update', 'updateConnectionDto', updateConnectionDto)
            const localVarPath = `/v1/provider/connections/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderConnectionApi - functional programming interface
 * @export
 */
export const ProviderConnectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderConnectionApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint securely stores the details of a provider connection, ensuring that all sensitive information is encrypted.
         * @summary Store a provider connection securely
         * @param {string} xClientId 
         * @param {CreateConnectionDto} createConnectionDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(xClientId: string, createConnectionDto: CreateConnectionDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(xClientId, createConnectionDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderConnectionApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves the details of a specific connection associated with the client, identified by the ID.
         * @summary Retrieve a specific connection by ID
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(xClientId: string, connectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(xClientId, connectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderConnectionApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint initiates a new connection by generating a public key and an encryption key for secure communication.
         * @summary Initiate a new provider connection
         * @param {string} xClientId 
         * @param {InitiateConnectionDto} initiateConnectionDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiate(xClientId: string, initiateConnectionDto: InitiateConnectionDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderPendingConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiate(xClientId, initiateConnectionDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderConnectionApi.initiate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of all connections associated with the client.
         * @summary List all connections
         * @param {string} xClientId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedConnectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderConnectionApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of accounts associated with a specific connection.
         * @summary List accounts for a specific connection
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(xClientId: string, connectionId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(xClientId, connectionId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderConnectionApi.listAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of wallets associated with a specific connection.
         * @summary List wallets for a specific connection
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWallets(xClientId: string, connectionId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWalletsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(xClientId, connectionId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderConnectionApi.listWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint revokes an existing connection, effectively terminating any ongoing communication and invalidating the connection credentials.
         * @summary Revoke an existing connection
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revoke(xClientId: string, connectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revoke(xClientId, connectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderConnectionApi.revoke']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint updates the details of a specific connection associated with the client, identified by the connection ID.
         * @summary Update a specific connection by ID
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {UpdateConnectionDto} updateConnectionDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(xClientId: string, connectionId: string, updateConnectionDto: UpdateConnectionDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(xClientId, connectionId, updateConnectionDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderConnectionApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderConnectionApi - factory interface
 * @export
 */
export const ProviderConnectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderConnectionApiFp(configuration)
    return {
        /**
         * This endpoint securely stores the details of a provider connection, ensuring that all sensitive information is encrypted.
         * @summary Store a provider connection securely
         * @param {ProviderConnectionApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ProviderConnectionApiCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProviderConnectionDto> {
            return localVarFp.create(requestParameters.xClientId, requestParameters.createConnectionDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves the details of a specific connection associated with the client, identified by the ID.
         * @summary Retrieve a specific connection by ID
         * @param {ProviderConnectionApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ProviderConnectionApiGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProviderConnectionDto> {
            return localVarFp.getById(requestParameters.xClientId, requestParameters.connectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint initiates a new connection by generating a public key and an encryption key for secure communication.
         * @summary Initiate a new provider connection
         * @param {ProviderConnectionApiInitiateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiate(requestParameters: ProviderConnectionApiInitiateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProviderPendingConnectionDto> {
            return localVarFp.initiate(requestParameters.xClientId, requestParameters.initiateConnectionDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of all connections associated with the client.
         * @summary List all connections
         * @param {ProviderConnectionApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ProviderConnectionApiListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedConnectionsDto> {
            return localVarFp.list(requestParameters.xClientId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of accounts associated with a specific connection.
         * @summary List accounts for a specific connection
         * @param {ProviderConnectionApiListAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(requestParameters: ProviderConnectionApiListAccountsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccountsDto> {
            return localVarFp.listAccounts(requestParameters.xClientId, requestParameters.connectionId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of wallets associated with a specific connection.
         * @summary List wallets for a specific connection
         * @param {ProviderConnectionApiListWalletsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets(requestParameters: ProviderConnectionApiListWalletsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWalletsDto> {
            return localVarFp.listWallets(requestParameters.xClientId, requestParameters.connectionId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint revokes an existing connection, effectively terminating any ongoing communication and invalidating the connection credentials.
         * @summary Revoke an existing connection
         * @param {ProviderConnectionApiRevokeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revoke(requestParameters: ProviderConnectionApiRevokeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revoke(requestParameters.xClientId, requestParameters.connectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates the details of a specific connection associated with the client, identified by the connection ID.
         * @summary Update a specific connection by ID
         * @param {ProviderConnectionApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ProviderConnectionApiUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProviderConnectionDto> {
            return localVarFp.update(requestParameters.xClientId, requestParameters.connectionId, requestParameters.updateConnectionDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in ProviderConnectionApi.
 * @export
 * @interface ProviderConnectionApiCreateRequest
 */
export interface ProviderConnectionApiCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiCreate
     */
    readonly xClientId: string

    /**
     * 
     * @type {CreateConnectionDto}
     * @memberof ProviderConnectionApiCreate
     */
    readonly createConnectionDto: CreateConnectionDto

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiCreate
     */
    readonly authorization?: string
}

/**
 * Request parameters for getById operation in ProviderConnectionApi.
 * @export
 * @interface ProviderConnectionApiGetByIdRequest
 */
export interface ProviderConnectionApiGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiGetById
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiGetById
     */
    readonly connectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiGetById
     */
    readonly authorization?: string
}

/**
 * Request parameters for initiate operation in ProviderConnectionApi.
 * @export
 * @interface ProviderConnectionApiInitiateRequest
 */
export interface ProviderConnectionApiInitiateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiInitiate
     */
    readonly xClientId: string

    /**
     * 
     * @type {InitiateConnectionDto}
     * @memberof ProviderConnectionApiInitiate
     */
    readonly initiateConnectionDto: InitiateConnectionDto

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiInitiate
     */
    readonly authorization?: string
}

/**
 * Request parameters for list operation in ProviderConnectionApi.
 * @export
 * @interface ProviderConnectionApiListRequest
 */
export interface ProviderConnectionApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiList
     */
    readonly xClientId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderConnectionApiList
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderConnectionApiList
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderConnectionApiList
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderConnectionApiList
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiList
     */
    readonly authorization?: string
}

/**
 * Request parameters for listAccounts operation in ProviderConnectionApi.
 * @export
 * @interface ProviderConnectionApiListAccountsRequest
 */
export interface ProviderConnectionApiListAccountsRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiListAccounts
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiListAccounts
     */
    readonly connectionId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderConnectionApiListAccounts
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderConnectionApiListAccounts
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderConnectionApiListAccounts
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderConnectionApiListAccounts
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiListAccounts
     */
    readonly authorization?: string
}

/**
 * Request parameters for listWallets operation in ProviderConnectionApi.
 * @export
 * @interface ProviderConnectionApiListWalletsRequest
 */
export interface ProviderConnectionApiListWalletsRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiListWallets
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiListWallets
     */
    readonly connectionId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderConnectionApiListWallets
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderConnectionApiListWallets
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderConnectionApiListWallets
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderConnectionApiListWallets
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiListWallets
     */
    readonly authorization?: string
}

/**
 * Request parameters for revoke operation in ProviderConnectionApi.
 * @export
 * @interface ProviderConnectionApiRevokeRequest
 */
export interface ProviderConnectionApiRevokeRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiRevoke
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiRevoke
     */
    readonly connectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiRevoke
     */
    readonly authorization?: string
}

/**
 * Request parameters for update operation in ProviderConnectionApi.
 * @export
 * @interface ProviderConnectionApiUpdateRequest
 */
export interface ProviderConnectionApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiUpdate
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiUpdate
     */
    readonly connectionId: string

    /**
     * 
     * @type {UpdateConnectionDto}
     * @memberof ProviderConnectionApiUpdate
     */
    readonly updateConnectionDto: UpdateConnectionDto

    /**
     * 
     * @type {string}
     * @memberof ProviderConnectionApiUpdate
     */
    readonly authorization?: string
}

/**
 * ProviderConnectionApi - object-oriented interface
 * @export
 * @class ProviderConnectionApi
 * @extends {BaseAPI}
 */
export class ProviderConnectionApi extends BaseAPI {
    /**
     * This endpoint securely stores the details of a provider connection, ensuring that all sensitive information is encrypted.
     * @summary Store a provider connection securely
     * @param {ProviderConnectionApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderConnectionApi
     */
    public create(requestParameters: ProviderConnectionApiCreateRequest, options?: RawAxiosRequestConfig) {
        return ProviderConnectionApiFp(this.configuration).create(requestParameters.xClientId, requestParameters.createConnectionDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves the details of a specific connection associated with the client, identified by the ID.
     * @summary Retrieve a specific connection by ID
     * @param {ProviderConnectionApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderConnectionApi
     */
    public getById(requestParameters: ProviderConnectionApiGetByIdRequest, options?: RawAxiosRequestConfig) {
        return ProviderConnectionApiFp(this.configuration).getById(requestParameters.xClientId, requestParameters.connectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint initiates a new connection by generating a public key and an encryption key for secure communication.
     * @summary Initiate a new provider connection
     * @param {ProviderConnectionApiInitiateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderConnectionApi
     */
    public initiate(requestParameters: ProviderConnectionApiInitiateRequest, options?: RawAxiosRequestConfig) {
        return ProviderConnectionApiFp(this.configuration).initiate(requestParameters.xClientId, requestParameters.initiateConnectionDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of all connections associated with the client.
     * @summary List all connections
     * @param {ProviderConnectionApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderConnectionApi
     */
    public list(requestParameters: ProviderConnectionApiListRequest, options?: RawAxiosRequestConfig) {
        return ProviderConnectionApiFp(this.configuration).list(requestParameters.xClientId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of accounts associated with a specific connection.
     * @summary List accounts for a specific connection
     * @param {ProviderConnectionApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderConnectionApi
     */
    public listAccounts(requestParameters: ProviderConnectionApiListAccountsRequest, options?: RawAxiosRequestConfig) {
        return ProviderConnectionApiFp(this.configuration).listAccounts(requestParameters.xClientId, requestParameters.connectionId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of wallets associated with a specific connection.
     * @summary List wallets for a specific connection
     * @param {ProviderConnectionApiListWalletsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderConnectionApi
     */
    public listWallets(requestParameters: ProviderConnectionApiListWalletsRequest, options?: RawAxiosRequestConfig) {
        return ProviderConnectionApiFp(this.configuration).listWallets(requestParameters.xClientId, requestParameters.connectionId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint revokes an existing connection, effectively terminating any ongoing communication and invalidating the connection credentials.
     * @summary Revoke an existing connection
     * @param {ProviderConnectionApiRevokeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderConnectionApi
     */
    public revoke(requestParameters: ProviderConnectionApiRevokeRequest, options?: RawAxiosRequestConfig) {
        return ProviderConnectionApiFp(this.configuration).revoke(requestParameters.xClientId, requestParameters.connectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates the details of a specific connection associated with the client, identified by the connection ID.
     * @summary Update a specific connection by ID
     * @param {ProviderConnectionApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderConnectionApi
     */
    public update(requestParameters: ProviderConnectionApiUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProviderConnectionApiFp(this.configuration).update(requestParameters.xClientId, requestParameters.connectionId, requestParameters.updateConnectionDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderKnownDestinationApi - axios parameter creator
 * @export
 */
export const ProviderKnownDestinationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get known destination by ID
         * @param {string} xClientId 
         * @param {string} knownDestinationId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (xClientId: string, knownDestinationId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getById', 'xClientId', xClientId)
            // verify required parameter 'knownDestinationId' is not null or undefined
            assertParamExists('getById', 'knownDestinationId', knownDestinationId)
            const localVarPath = `/v1/provider/known-destinations/{knownDestinationId}`
                .replace(`{${"knownDestinationId"}}`, encodeURIComponent(String(knownDestinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get known destinations across providers
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, connectionId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('list', 'connectionId', connectionId)
            const localVarPath = `/v1/provider/known-destinations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (connectionId !== undefined) {
                localVarQueryParameter['connectionId'] = connectionId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderKnownDestinationApi - functional programming interface
 * @export
 */
export const ProviderKnownDestinationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderKnownDestinationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get known destination by ID
         * @param {string} xClientId 
         * @param {string} knownDestinationId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(xClientId: string, knownDestinationId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnownDestinationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(xClientId, knownDestinationId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderKnownDestinationApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get known destinations across providers
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, connectionId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedKnownDestinationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, connectionId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderKnownDestinationApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderKnownDestinationApi - factory interface
 * @export
 */
export const ProviderKnownDestinationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderKnownDestinationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get known destination by ID
         * @param {ProviderKnownDestinationApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ProviderKnownDestinationApiGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<KnownDestinationDto> {
            return localVarFp.getById(requestParameters.xClientId, requestParameters.knownDestinationId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get known destinations across providers
         * @param {ProviderKnownDestinationApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ProviderKnownDestinationApiListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedKnownDestinationsDto> {
            return localVarFp.list(requestParameters.xClientId, requestParameters.connectionId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getById operation in ProviderKnownDestinationApi.
 * @export
 * @interface ProviderKnownDestinationApiGetByIdRequest
 */
export interface ProviderKnownDestinationApiGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderKnownDestinationApiGetById
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderKnownDestinationApiGetById
     */
    readonly knownDestinationId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderKnownDestinationApiGetById
     */
    readonly authorization?: string
}

/**
 * Request parameters for list operation in ProviderKnownDestinationApi.
 * @export
 * @interface ProviderKnownDestinationApiListRequest
 */
export interface ProviderKnownDestinationApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderKnownDestinationApiList
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderKnownDestinationApiList
     */
    readonly connectionId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderKnownDestinationApiList
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderKnownDestinationApiList
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderKnownDestinationApiList
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderKnownDestinationApiList
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderKnownDestinationApiList
     */
    readonly authorization?: string
}

/**
 * ProviderKnownDestinationApi - object-oriented interface
 * @export
 * @class ProviderKnownDestinationApi
 * @extends {BaseAPI}
 */
export class ProviderKnownDestinationApi extends BaseAPI {
    /**
     * 
     * @summary Get known destination by ID
     * @param {ProviderKnownDestinationApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderKnownDestinationApi
     */
    public getById(requestParameters: ProviderKnownDestinationApiGetByIdRequest, options?: RawAxiosRequestConfig) {
        return ProviderKnownDestinationApiFp(this.configuration).getById(requestParameters.xClientId, requestParameters.knownDestinationId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get known destinations across providers
     * @param {ProviderKnownDestinationApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderKnownDestinationApi
     */
    public list(requestParameters: ProviderKnownDestinationApiListRequest, options?: RawAxiosRequestConfig) {
        return ProviderKnownDestinationApiFp(this.configuration).list(requestParameters.xClientId, requestParameters.connectionId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderProxyApi - axios parameter creator
 * @export
 */
export const ProviderProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('_delete', 'xClientId', xClientId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('_delete', 'endpoint', endpoint)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('_delete', 'xConnectionId', xConnectionId)
            const localVarPath = `/v1/provider/proxy/{endpoint}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _options: async (xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('_options', 'xClientId', xClientId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('_options', 'endpoint', endpoint)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('_options', 'xConnectionId', xConnectionId)
            const localVarPath = `/v1/provider/proxy/{endpoint}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('get', 'xClientId', xClientId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('get', 'endpoint', endpoint)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('get', 'xConnectionId', xConnectionId)
            const localVarPath = `/v1/provider/proxy/{endpoint}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        head: async (xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('head', 'xClientId', xClientId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('head', 'endpoint', endpoint)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('head', 'xConnectionId', xConnectionId)
            const localVarPath = `/v1/provider/proxy/{endpoint}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patch: async (xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('patch', 'xClientId', xClientId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('patch', 'endpoint', endpoint)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('patch', 'xConnectionId', xConnectionId)
            const localVarPath = `/v1/provider/proxy/{endpoint}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: async (xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('post', 'xClientId', xClientId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('post', 'endpoint', endpoint)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('post', 'xConnectionId', xConnectionId)
            const localVarPath = `/v1/provider/proxy/{endpoint}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put: async (xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('put', 'xClientId', xClientId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('put', 'endpoint', endpoint)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('put', 'xConnectionId', xConnectionId)
            const localVarPath = `/v1/provider/proxy/{endpoint}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderProxyApi - functional programming interface
 * @export
 */
export const ProviderProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(xClientId, endpoint, xConnectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderProxyApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _options(xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._options(xClientId, endpoint, xConnectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderProxyApi._options']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(xClientId, endpoint, xConnectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderProxyApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async head(xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.head(xClientId, endpoint, xConnectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderProxyApi.head']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patch(xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patch(xClientId, endpoint, xConnectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderProxyApi.patch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async post(xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.post(xClientId, endpoint, xConnectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderProxyApi.post']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {string} xClientId 
         * @param {string} endpoint The raw endpoint path in the provider
         * @param {string} xConnectionId The connection ID used to forward request to provider
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async put(xClientId: string, endpoint: string, xConnectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.put(xClientId, endpoint, xConnectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderProxyApi.put']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderProxyApi - factory interface
 * @export
 */
export const ProviderProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderProxyApiFp(configuration)
    return {
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {ProviderProxyApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: ProviderProxyApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._delete(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {ProviderProxyApiOptionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _options(requestParameters: ProviderProxyApiOptionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._options(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {ProviderProxyApiGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(requestParameters: ProviderProxyApiGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.get(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {ProviderProxyApiHeadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        head(requestParameters: ProviderProxyApiHeadRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.head(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {ProviderProxyApiPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patch(requestParameters: ProviderProxyApiPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.patch(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {ProviderProxyApiPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(requestParameters: ProviderProxyApiPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.post(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
         * @summary Authorizes and forwards the request to the provider
         * @param {ProviderProxyApiPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(requestParameters: ProviderProxyApiPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.put(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in ProviderProxyApi.
 * @export
 * @interface ProviderProxyApiDeleteRequest
 */
export interface ProviderProxyApiDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiDelete
     */
    readonly xClientId: string

    /**
     * The raw endpoint path in the provider
     * @type {string}
     * @memberof ProviderProxyApiDelete
     */
    readonly endpoint: string

    /**
     * The connection ID used to forward request to provider
     * @type {string}
     * @memberof ProviderProxyApiDelete
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiDelete
     */
    readonly authorization?: string
}

/**
 * Request parameters for _options operation in ProviderProxyApi.
 * @export
 * @interface ProviderProxyApiOptionsRequest
 */
export interface ProviderProxyApiOptionsRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiOptions
     */
    readonly xClientId: string

    /**
     * The raw endpoint path in the provider
     * @type {string}
     * @memberof ProviderProxyApiOptions
     */
    readonly endpoint: string

    /**
     * The connection ID used to forward request to provider
     * @type {string}
     * @memberof ProviderProxyApiOptions
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiOptions
     */
    readonly authorization?: string
}

/**
 * Request parameters for get operation in ProviderProxyApi.
 * @export
 * @interface ProviderProxyApiGetRequest
 */
export interface ProviderProxyApiGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiGet
     */
    readonly xClientId: string

    /**
     * The raw endpoint path in the provider
     * @type {string}
     * @memberof ProviderProxyApiGet
     */
    readonly endpoint: string

    /**
     * The connection ID used to forward request to provider
     * @type {string}
     * @memberof ProviderProxyApiGet
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiGet
     */
    readonly authorization?: string
}

/**
 * Request parameters for head operation in ProviderProxyApi.
 * @export
 * @interface ProviderProxyApiHeadRequest
 */
export interface ProviderProxyApiHeadRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiHead
     */
    readonly xClientId: string

    /**
     * The raw endpoint path in the provider
     * @type {string}
     * @memberof ProviderProxyApiHead
     */
    readonly endpoint: string

    /**
     * The connection ID used to forward request to provider
     * @type {string}
     * @memberof ProviderProxyApiHead
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiHead
     */
    readonly authorization?: string
}

/**
 * Request parameters for patch operation in ProviderProxyApi.
 * @export
 * @interface ProviderProxyApiPatchRequest
 */
export interface ProviderProxyApiPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiPatch
     */
    readonly xClientId: string

    /**
     * The raw endpoint path in the provider
     * @type {string}
     * @memberof ProviderProxyApiPatch
     */
    readonly endpoint: string

    /**
     * The connection ID used to forward request to provider
     * @type {string}
     * @memberof ProviderProxyApiPatch
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiPatch
     */
    readonly authorization?: string
}

/**
 * Request parameters for post operation in ProviderProxyApi.
 * @export
 * @interface ProviderProxyApiPostRequest
 */
export interface ProviderProxyApiPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiPost
     */
    readonly xClientId: string

    /**
     * The raw endpoint path in the provider
     * @type {string}
     * @memberof ProviderProxyApiPost
     */
    readonly endpoint: string

    /**
     * The connection ID used to forward request to provider
     * @type {string}
     * @memberof ProviderProxyApiPost
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiPost
     */
    readonly authorization?: string
}

/**
 * Request parameters for put operation in ProviderProxyApi.
 * @export
 * @interface ProviderProxyApiPutRequest
 */
export interface ProviderProxyApiPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiPut
     */
    readonly xClientId: string

    /**
     * The raw endpoint path in the provider
     * @type {string}
     * @memberof ProviderProxyApiPut
     */
    readonly endpoint: string

    /**
     * The connection ID used to forward request to provider
     * @type {string}
     * @memberof ProviderProxyApiPut
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderProxyApiPut
     */
    readonly authorization?: string
}

/**
 * ProviderProxyApi - object-oriented interface
 * @export
 * @class ProviderProxyApi
 * @extends {BaseAPI}
 */
export class ProviderProxyApi extends BaseAPI {
    /**
     * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
     * @summary Authorizes and forwards the request to the provider
     * @param {ProviderProxyApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProxyApi
     */
    public _delete(requestParameters: ProviderProxyApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return ProviderProxyApiFp(this.configuration)._delete(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
     * @summary Authorizes and forwards the request to the provider
     * @param {ProviderProxyApiOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProxyApi
     */
    public _options(requestParameters: ProviderProxyApiOptionsRequest, options?: RawAxiosRequestConfig) {
        return ProviderProxyApiFp(this.configuration)._options(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
     * @summary Authorizes and forwards the request to the provider
     * @param {ProviderProxyApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProxyApi
     */
    public get(requestParameters: ProviderProxyApiGetRequest, options?: RawAxiosRequestConfig) {
        return ProviderProxyApiFp(this.configuration).get(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
     * @summary Authorizes and forwards the request to the provider
     * @param {ProviderProxyApiHeadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProxyApi
     */
    public head(requestParameters: ProviderProxyApiHeadRequest, options?: RawAxiosRequestConfig) {
        return ProviderProxyApiFp(this.configuration).head(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
     * @summary Authorizes and forwards the request to the provider
     * @param {ProviderProxyApiPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProxyApi
     */
    public patch(requestParameters: ProviderProxyApiPatchRequest, options?: RawAxiosRequestConfig) {
        return ProviderProxyApiFp(this.configuration).patch(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
     * @summary Authorizes and forwards the request to the provider
     * @param {ProviderProxyApiPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProxyApi
     */
    public post(requestParameters: ProviderProxyApiPostRequest, options?: RawAxiosRequestConfig) {
        return ProviderProxyApiFp(this.configuration).post(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint uses the connection specified in the header to authorize and forward the request in the path to the provider.
     * @summary Authorizes and forwards the request to the provider
     * @param {ProviderProxyApiPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProxyApi
     */
    public put(requestParameters: ProviderProxyApiPutRequest, options?: RawAxiosRequestConfig) {
        return ProviderProxyApiFp(this.configuration).put(requestParameters.xClientId, requestParameters.endpoint, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderSyncApi - axios parameter creator
 * @export
 */
export const ProviderSyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves the details of a specific synchronization process associated with the client, identified by the sync ID.
         * @summary Retrieve a specific synchronization process by ID
         * @param {string} xClientId 
         * @param {string} syncId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (xClientId: string, syncId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getById', 'xClientId', xClientId)
            // verify required parameter 'syncId' is not null or undefined
            assertParamExists('getById', 'syncId', syncId)
            const localVarPath = `/v1/provider/syncs/{syncId}`
                .replace(`{${"syncId"}}`, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of synchronization processes associated with the client. Optionally, it can filter the processes by a specific connection ID.
         * @summary Retrieve a list of synchronization processes
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, connectionId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('list', 'connectionId', connectionId)
            const localVarPath = `/v1/provider/syncs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (connectionId !== undefined) {
                localVarQueryParameter['connectionId'] = connectionId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint starts synchronization process for the client.
         * @summary Start a synchronization process
         * @param {string} xClientId 
         * @param {StartSyncDto} startSyncDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start: async (xClientId: string, startSyncDto: StartSyncDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('start', 'xClientId', xClientId)
            // verify required parameter 'startSyncDto' is not null or undefined
            assertParamExists('start', 'startSyncDto', startSyncDto)
            const localVarPath = `/v1/provider/syncs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startSyncDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderSyncApi - functional programming interface
 * @export
 */
export const ProviderSyncApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderSyncApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves the details of a specific synchronization process associated with the client, identified by the sync ID.
         * @summary Retrieve a specific synchronization process by ID
         * @param {string} xClientId 
         * @param {string} syncId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(xClientId: string, syncId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(xClientId, syncId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderSyncApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of synchronization processes associated with the client. Optionally, it can filter the processes by a specific connection ID.
         * @summary Retrieve a list of synchronization processes
         * @param {string} xClientId 
         * @param {string} connectionId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, connectionId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, connectionId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderSyncApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint starts synchronization process for the client.
         * @summary Start a synchronization process
         * @param {string} xClientId 
         * @param {StartSyncDto} startSyncDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async start(xClientId: string, startSyncDto: StartSyncDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncStartedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.start(xClientId, startSyncDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderSyncApi.start']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderSyncApi - factory interface
 * @export
 */
export const ProviderSyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderSyncApiFp(configuration)
    return {
        /**
         * This endpoint retrieves the details of a specific synchronization process associated with the client, identified by the sync ID.
         * @summary Retrieve a specific synchronization process by ID
         * @param {ProviderSyncApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ProviderSyncApiGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncDto> {
            return localVarFp.getById(requestParameters.xClientId, requestParameters.syncId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of synchronization processes associated with the client. Optionally, it can filter the processes by a specific connection ID.
         * @summary Retrieve a list of synchronization processes
         * @param {ProviderSyncApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ProviderSyncApiListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSyncsDto> {
            return localVarFp.list(requestParameters.xClientId, requestParameters.connectionId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint starts synchronization process for the client.
         * @summary Start a synchronization process
         * @param {ProviderSyncApiStartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(requestParameters: ProviderSyncApiStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncStartedDto> {
            return localVarFp.start(requestParameters.xClientId, requestParameters.startSyncDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getById operation in ProviderSyncApi.
 * @export
 * @interface ProviderSyncApiGetByIdRequest
 */
export interface ProviderSyncApiGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderSyncApiGetById
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderSyncApiGetById
     */
    readonly syncId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderSyncApiGetById
     */
    readonly authorization?: string
}

/**
 * Request parameters for list operation in ProviderSyncApi.
 * @export
 * @interface ProviderSyncApiListRequest
 */
export interface ProviderSyncApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderSyncApiList
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderSyncApiList
     */
    readonly connectionId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderSyncApiList
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderSyncApiList
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderSyncApiList
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderSyncApiList
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderSyncApiList
     */
    readonly authorization?: string
}

/**
 * Request parameters for start operation in ProviderSyncApi.
 * @export
 * @interface ProviderSyncApiStartRequest
 */
export interface ProviderSyncApiStartRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderSyncApiStart
     */
    readonly xClientId: string

    /**
     * 
     * @type {StartSyncDto}
     * @memberof ProviderSyncApiStart
     */
    readonly startSyncDto: StartSyncDto

    /**
     * 
     * @type {string}
     * @memberof ProviderSyncApiStart
     */
    readonly authorization?: string
}

/**
 * ProviderSyncApi - object-oriented interface
 * @export
 * @class ProviderSyncApi
 * @extends {BaseAPI}
 */
export class ProviderSyncApi extends BaseAPI {
    /**
     * This endpoint retrieves the details of a specific synchronization process associated with the client, identified by the sync ID.
     * @summary Retrieve a specific synchronization process by ID
     * @param {ProviderSyncApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderSyncApi
     */
    public getById(requestParameters: ProviderSyncApiGetByIdRequest, options?: RawAxiosRequestConfig) {
        return ProviderSyncApiFp(this.configuration).getById(requestParameters.xClientId, requestParameters.syncId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of synchronization processes associated with the client. Optionally, it can filter the processes by a specific connection ID.
     * @summary Retrieve a list of synchronization processes
     * @param {ProviderSyncApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderSyncApi
     */
    public list(requestParameters: ProviderSyncApiListRequest, options?: RawAxiosRequestConfig) {
        return ProviderSyncApiFp(this.configuration).list(requestParameters.xClientId, requestParameters.connectionId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint starts synchronization process for the client.
     * @summary Start a synchronization process
     * @param {ProviderSyncApiStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderSyncApi
     */
    public start(requestParameters: ProviderSyncApiStartRequest, options?: RawAxiosRequestConfig) {
        return ProviderSyncApiFp(this.configuration).start(requestParameters.xClientId, requestParameters.startSyncDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderTransferApi - axios parameter creator
 * @export
 */
export const ProviderTransferApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves the details of a specific transfer using its ID.
         * @summary Retrieve transfer details
         * @param {string} xClientId 
         * @param {string} transferId 
         * @param {string} xConnectionId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (xClientId: string, transferId: string, xConnectionId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getById', 'xClientId', xClientId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('getById', 'transferId', transferId)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('getById', 'xConnectionId', xConnectionId)
            const localVarPath = `/v1/provider/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sends a transfer to the source\'s provider.
         * @summary Send a transfer
         * @param {string} xClientId 
         * @param {string} xConnectionId 
         * @param {SendTransferDto} sendTransferDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send: async (xClientId: string, xConnectionId: string, sendTransferDto: SendTransferDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('send', 'xClientId', xClientId)
            // verify required parameter 'xConnectionId' is not null or undefined
            assertParamExists('send', 'xConnectionId', xConnectionId)
            // verify required parameter 'sendTransferDto' is not null or undefined
            assertParamExists('send', 'sendTransferDto', sendTransferDto)
            const localVarPath = `/v1/provider/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (xConnectionId != null) {
                localVarHeaderParameter['x-connection-id'] = String(xConnectionId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendTransferDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderTransferApi - functional programming interface
 * @export
 */
export const ProviderTransferApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderTransferApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves the details of a specific transfer using its ID.
         * @summary Retrieve transfer details
         * @param {string} xClientId 
         * @param {string} transferId 
         * @param {string} xConnectionId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(xClientId: string, transferId: string, xConnectionId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(xClientId, transferId, xConnectionId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderTransferApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sends a transfer to the source\'s provider.
         * @summary Send a transfer
         * @param {string} xClientId 
         * @param {string} xConnectionId 
         * @param {SendTransferDto} sendTransferDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async send(xClientId: string, xConnectionId: string, sendTransferDto: SendTransferDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.send(xClientId, xConnectionId, sendTransferDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderTransferApi.send']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderTransferApi - factory interface
 * @export
 */
export const ProviderTransferApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderTransferApiFp(configuration)
    return {
        /**
         * This endpoint retrieves the details of a specific transfer using its ID.
         * @summary Retrieve transfer details
         * @param {ProviderTransferApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ProviderTransferApiGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransferDto> {
            return localVarFp.getById(requestParameters.xClientId, requestParameters.transferId, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sends a transfer to the source\'s provider.
         * @summary Send a transfer
         * @param {ProviderTransferApiSendRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        send(requestParameters: ProviderTransferApiSendRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransferDto> {
            return localVarFp.send(requestParameters.xClientId, requestParameters.xConnectionId, requestParameters.sendTransferDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getById operation in ProviderTransferApi.
 * @export
 * @interface ProviderTransferApiGetByIdRequest
 */
export interface ProviderTransferApiGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderTransferApiGetById
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderTransferApiGetById
     */
    readonly transferId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderTransferApiGetById
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderTransferApiGetById
     */
    readonly authorization?: string
}

/**
 * Request parameters for send operation in ProviderTransferApi.
 * @export
 * @interface ProviderTransferApiSendRequest
 */
export interface ProviderTransferApiSendRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderTransferApiSend
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderTransferApiSend
     */
    readonly xConnectionId: string

    /**
     * 
     * @type {SendTransferDto}
     * @memberof ProviderTransferApiSend
     */
    readonly sendTransferDto: SendTransferDto

    /**
     * 
     * @type {string}
     * @memberof ProviderTransferApiSend
     */
    readonly authorization?: string
}

/**
 * ProviderTransferApi - object-oriented interface
 * @export
 * @class ProviderTransferApi
 * @extends {BaseAPI}
 */
export class ProviderTransferApi extends BaseAPI {
    /**
     * This endpoint retrieves the details of a specific transfer using its ID.
     * @summary Retrieve transfer details
     * @param {ProviderTransferApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderTransferApi
     */
    public getById(requestParameters: ProviderTransferApiGetByIdRequest, options?: RawAxiosRequestConfig) {
        return ProviderTransferApiFp(this.configuration).getById(requestParameters.xClientId, requestParameters.transferId, requestParameters.xConnectionId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sends a transfer to the source\'s provider.
     * @summary Send a transfer
     * @param {ProviderTransferApiSendRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderTransferApi
     */
    public send(requestParameters: ProviderTransferApiSendRequest, options?: RawAxiosRequestConfig) {
        return ProviderTransferApiFp(this.configuration).send(requestParameters.xClientId, requestParameters.xConnectionId, requestParameters.sendTransferDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderWalletApi - axios parameter creator
 * @export
 */
export const ProviderWalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a specific wallet by ID
         * @param {string} xClientId 
         * @param {string} walletId The ID of the wallet to retrieve
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (xClientId: string, walletId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getById', 'xClientId', xClientId)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getById', 'walletId', walletId)
            const localVarPath = `/v1/provider/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            const localVarPath = `/v1/provider/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List accounts for a specific wallet
         * @param {string} xClientId 
         * @param {string} walletId The ID of the wallet to retrieve accounts for
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (xClientId: string, walletId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('listAccounts', 'xClientId', xClientId)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('listAccounts', 'walletId', walletId)
            const localVarPath = `/v1/provider/wallets/{walletId}/accounts`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderWalletApi - functional programming interface
 * @export
 */
export const ProviderWalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderWalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a specific wallet by ID
         * @param {string} xClientId 
         * @param {string} walletId The ID of the wallet to retrieve
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(xClientId: string, walletId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderWalletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(xClientId, walletId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderWalletApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWalletsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderWalletApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List accounts for a specific wallet
         * @param {string} xClientId 
         * @param {string} walletId The ID of the wallet to retrieve accounts for
         * @param {string} [cursor] Cursor for pagination. Use the next cursor from previous response to get next page
         * @param {number} [limit] Number of records to return per page
         * @param {string} [orderBy] Field to order results by
         * @param {string} [desc] Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(xClientId: string, walletId: string, cursor?: string, limit?: number, orderBy?: string, desc?: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(xClientId, walletId, cursor, limit, orderBy, desc, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderWalletApi.listAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderWalletApi - factory interface
 * @export
 */
export const ProviderWalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderWalletApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a specific wallet by ID
         * @param {ProviderWalletApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ProviderWalletApiGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProviderWalletDto> {
            return localVarFp.getById(requestParameters.xClientId, requestParameters.walletId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the client wallets
         * @param {ProviderWalletApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ProviderWalletApiListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWalletsDto> {
            return localVarFp.list(requestParameters.xClientId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List accounts for a specific wallet
         * @param {ProviderWalletApiListAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(requestParameters: ProviderWalletApiListAccountsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccountsDto> {
            return localVarFp.listAccounts(requestParameters.xClientId, requestParameters.walletId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getById operation in ProviderWalletApi.
 * @export
 * @interface ProviderWalletApiGetByIdRequest
 */
export interface ProviderWalletApiGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderWalletApiGetById
     */
    readonly xClientId: string

    /**
     * The ID of the wallet to retrieve
     * @type {string}
     * @memberof ProviderWalletApiGetById
     */
    readonly walletId: string

    /**
     * 
     * @type {string}
     * @memberof ProviderWalletApiGetById
     */
    readonly authorization?: string
}

/**
 * Request parameters for list operation in ProviderWalletApi.
 * @export
 * @interface ProviderWalletApiListRequest
 */
export interface ProviderWalletApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderWalletApiList
     */
    readonly xClientId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderWalletApiList
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderWalletApiList
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderWalletApiList
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderWalletApiList
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderWalletApiList
     */
    readonly authorization?: string
}

/**
 * Request parameters for listAccounts operation in ProviderWalletApi.
 * @export
 * @interface ProviderWalletApiListAccountsRequest
 */
export interface ProviderWalletApiListAccountsRequest {
    /**
     * 
     * @type {string}
     * @memberof ProviderWalletApiListAccounts
     */
    readonly xClientId: string

    /**
     * The ID of the wallet to retrieve accounts for
     * @type {string}
     * @memberof ProviderWalletApiListAccounts
     */
    readonly walletId: string

    /**
     * Cursor for pagination. Use the next cursor from previous response to get next page
     * @type {string}
     * @memberof ProviderWalletApiListAccounts
     */
    readonly cursor?: string

    /**
     * Number of records to return per page
     * @type {number}
     * @memberof ProviderWalletApiListAccounts
     */
    readonly limit?: number

    /**
     * Field to order results by
     * @type {string}
     * @memberof ProviderWalletApiListAccounts
     */
    readonly orderBy?: string

    /**
     * Set to \&quot;true\&quot; or \&quot;1\&quot; for descending order
     * @type {string}
     * @memberof ProviderWalletApiListAccounts
     */
    readonly desc?: string

    /**
     * 
     * @type {string}
     * @memberof ProviderWalletApiListAccounts
     */
    readonly authorization?: string
}

/**
 * ProviderWalletApi - object-oriented interface
 * @export
 * @class ProviderWalletApi
 * @extends {BaseAPI}
 */
export class ProviderWalletApi extends BaseAPI {
    /**
     * 
     * @summary Get a specific wallet by ID
     * @param {ProviderWalletApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderWalletApi
     */
    public getById(requestParameters: ProviderWalletApiGetByIdRequest, options?: RawAxiosRequestConfig) {
        return ProviderWalletApiFp(this.configuration).getById(requestParameters.xClientId, requestParameters.walletId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the client wallets
     * @param {ProviderWalletApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderWalletApi
     */
    public list(requestParameters: ProviderWalletApiListRequest, options?: RawAxiosRequestConfig) {
        return ProviderWalletApiFp(this.configuration).list(requestParameters.xClientId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List accounts for a specific wallet
     * @param {ProviderWalletApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderWalletApi
     */
    public listAccounts(requestParameters: ProviderWalletApiListAccountsRequest, options?: RawAxiosRequestConfig) {
        return ProviderWalletApiFp(this.configuration).listAccounts(requestParameters.xClientId, requestParameters.walletId, requestParameters.cursor, requestParameters.limit, requestParameters.orderBy, requestParameters.desc, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignApi - axios parameter creator
 * @export
 */
export const SignApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {string} xClientId 
         * @param {SignRequestDto} signRequestDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign: async (xClientId: string, signRequestDto: SignRequestDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('sign', 'xClientId', xClientId)
            // verify required parameter 'signRequestDto' is not null or undefined
            assertParamExists('sign', 'signRequestDto', signRequestDto)
            const localVarPath = `/v1/sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignApi - functional programming interface
 * @export
 */
export const SignApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {string} xClientId 
         * @param {SignRequestDto} signRequestDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sign(xClientId: string, signRequestDto: SignRequestDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sign(xClientId, signRequestDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignApi.sign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SignApi - factory interface
 * @export
 */
export const SignApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignApiFp(configuration)
    return {
        /**
         * 
         * @summary Signs the given request
         * @param {SignApiSignRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(requestParameters: SignApiSignRequest, options?: RawAxiosRequestConfig): AxiosPromise<SignatureDto> {
            return localVarFp.sign(requestParameters.xClientId, requestParameters.signRequestDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for sign operation in SignApi.
 * @export
 * @interface SignApiSignRequest
 */
export interface SignApiSignRequest {
    /**
     * 
     * @type {string}
     * @memberof SignApiSign
     */
    readonly xClientId: string

    /**
     * 
     * @type {SignRequestDto}
     * @memberof SignApiSign
     */
    readonly signRequestDto: SignRequestDto

    /**
     * 
     * @type {string}
     * @memberof SignApiSign
     */
    readonly authorization?: string
}

/**
 * SignApi - object-oriented interface
 * @export
 * @class SignApi
 * @extends {BaseAPI}
 */
export class SignApi extends BaseAPI {
    /**
     * 
     * @summary Signs the given request
     * @param {SignApiSignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public sign(requestParameters: SignApiSignRequest, options?: RawAxiosRequestConfig) {
        return SignApiFp(this.configuration).sign(requestParameters.xClientId, requestParameters.signRequestDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {string} xClientId 
         * @param {GenerateWalletDto} generateWalletDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (xClientId: string, generateWalletDto: GenerateWalletDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generate', 'xClientId', xClientId)
            // verify required parameter 'generateWalletDto' is not null or undefined
            assertParamExists('generate', 'generateWalletDto', generateWalletDto)
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateWalletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {string} xClientId 
         * @param {ImportWalletDto} importWalletDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSeed: async (xClientId: string, importWalletDto: ImportWalletDto, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('importSeed', 'xClientId', xClientId)
            // verify required parameter 'importWalletDto' is not null or undefined
            assertParamExists('importSeed', 'importWalletDto', importWalletDto)
            const localVarPath = `/v1/wallets/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importWalletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (xClientId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('list', 'xClientId', xClientId)
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication GNAP required

            // authentication Detached-JWS-Signature required
            await setApiKeyToObject(localVarHeaderParameter, "detached-jws", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['x-client-id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {string} xClientId 
         * @param {GenerateWalletDto} generateWalletDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(xClientId: string, generateWalletDto: GenerateWalletDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(xClientId, generateWalletDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.generate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {string} xClientId 
         * @param {ImportWalletDto} importWalletDto 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importSeed(xClientId: string, importWalletDto: ImportWalletDto, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSeed(xClientId, importWalletDto, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.importSeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the client wallets
         * @param {string} xClientId 
         * @param {string} [authorization] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(xClientId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(xClientId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * 
         * @summary Generates a new wallet
         * @param {WalletApiGenerateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(requestParameters: WalletApiGenerateRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletDto> {
            return localVarFp.generate(requestParameters.xClientId, requestParameters.generateWalletDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Imports a wallet
         * @param {WalletApiImportSeedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSeed(requestParameters: WalletApiImportSeedRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletDto> {
            return localVarFp.importSeed(requestParameters.xClientId, requestParameters.importWalletDto, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the client wallets
         * @param {WalletApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: WalletApiListRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletsDto> {
            return localVarFp.list(requestParameters.xClientId, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for generate operation in WalletApi.
 * @export
 * @interface WalletApiGenerateRequest
 */
export interface WalletApiGenerateRequest {
    /**
     * 
     * @type {string}
     * @memberof WalletApiGenerate
     */
    readonly xClientId: string

    /**
     * 
     * @type {GenerateWalletDto}
     * @memberof WalletApiGenerate
     */
    readonly generateWalletDto: GenerateWalletDto

    /**
     * 
     * @type {string}
     * @memberof WalletApiGenerate
     */
    readonly authorization?: string
}

/**
 * Request parameters for importSeed operation in WalletApi.
 * @export
 * @interface WalletApiImportSeedRequest
 */
export interface WalletApiImportSeedRequest {
    /**
     * 
     * @type {string}
     * @memberof WalletApiImportSeed
     */
    readonly xClientId: string

    /**
     * 
     * @type {ImportWalletDto}
     * @memberof WalletApiImportSeed
     */
    readonly importWalletDto: ImportWalletDto

    /**
     * 
     * @type {string}
     * @memberof WalletApiImportSeed
     */
    readonly authorization?: string
}

/**
 * Request parameters for list operation in WalletApi.
 * @export
 * @interface WalletApiListRequest
 */
export interface WalletApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof WalletApiList
     */
    readonly xClientId: string

    /**
     * 
     * @type {string}
     * @memberof WalletApiList
     */
    readonly authorization?: string
}

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * 
     * @summary Generates a new wallet
     * @param {WalletApiGenerateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public generate(requestParameters: WalletApiGenerateRequest, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).generate(requestParameters.xClientId, requestParameters.generateWalletDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Imports a wallet
     * @param {WalletApiImportSeedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public importSeed(requestParameters: WalletApiImportSeedRequest, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).importSeed(requestParameters.xClientId, requestParameters.importWalletDto, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the client wallets
     * @param {WalletApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public list(requestParameters: WalletApiListRequest, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).list(requestParameters.xClientId, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



