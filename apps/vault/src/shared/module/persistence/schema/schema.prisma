generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
  // Output into a separate subdirectory so multiple schemas can be used in a
  // monorepo.
  //
  // Reference: https://github.com/nrwl/nx-recipes/tree/main/nestjs-prisma
  output        = "../../../../../../../node_modules/@prisma/client/vault"
}

datasource db {
  provider = "postgresql"
  url      = env("APP_DATABASE_URL")
}

model Vault {
  id          String  @id
  masterKey   String? @map("master_key")
  adminApiKey String? @map("admin_api_key")

  @@map("vault")
}

// TODO: (@wcalderipe, 12/03/23) use hstore extension for better performance.
// See https://www.postgresql.org/docs/9.1/hstore.html
model KeyValue {
  key        String  @id
  clientId   String? @map("client_id")
  collection String
  value      String

  @@map("key_value")
}

model TransitEncryptionKey {
  id         String @id @default(cuid())
  clientId   String @map("client_id")
  privateKey Json @map("private_key")
  publicKey  Json @map("public_key")

  createdAt DateTime @default(now())

  @@map("transit_encryption_key")
}

model ProviderWallet {
  id         String   @id
  label      String?
  clientId   String   @map("client_id")
  provider   String
  externalId String   @map("external_id")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  accounts        ProviderAccount[]
  connections     ProviderWalletConnection[]
  sourceTransfers ProviderTransfer[]         @relation("SourceWallet")

  @@unique([clientId, externalId])

  @@map("provider_wallet")
}

model ProviderAccount {
  id         String   @id
  label      String?
  clientId   String   @map("client_id")
  provider   String
  externalId String   @map("external_id")
  walletId   String   @map("wallet_id")
  networkId  String   @map("network_id")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  wallet    ProviderWallet    @relation(fields: [walletId], references: [id])
  addresses ProviderAddress[]

  sourceTransfers ProviderTransfer[] @relation("SourceAccount")

  @@unique([clientId, externalId])

  @@map("provider_account")
}

model ProviderAddress {
  id         String   @id
  clientId   String   @map("client_id")
  provider   String
  externalId String   @map("external_id")
  accountId  String   @map("account_id")
  address    String
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  account ProviderAccount @relation(fields: [accountId], references: [id])

  sourceTransfers ProviderTransfer[] @relation("SourceAddress")

  @@unique([clientId, externalId])

  @@map("provider_address")
}

model ProviderKnownDestination {
  id                     String   @id
  clientId               String   @map("client_id")
  connectionId           String   @map("connection_id")
  provider               String
  externalId             String   @map("external_id")
  externalClassification String?  @map("external_classification")
  address                String
  assetId                String?  @map("asset_id")
  networkId              String   @map("network_id")
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")

  connection ProviderConnection @relation(fields: [connectionId], references: [id])

  @@unique([clientId, externalId])

  @@map("provider_known_destination")
}

model ProviderConnection {
  id          String    @id
  clientId    String    @map("client_id")
  provider    String
  url         String?
  label       String?
  credentials Json?
  status      String
  integrity   String    @map("_integrity")
  // IMPORTANT: Don't default DateTime to `now()` on this table because the
  // integrity column needs to hash all data at the application level.
  createdAt   DateTime  @map("created_at")
  updatedAt   DateTime  @map("updated_at")
  revokedAt   DateTime? @map("revoked_at")

  knownDestinations ProviderKnownDestination[]
  connections       ProviderWalletConnection[]
  syncs             ProviderSync[]

  @@map("provider_connection")
}

model ProviderWalletConnection {
  clientId     String   @map("client_id")
  connectionId String   @map("connection_id")
  walletId     String   @map("wallet_id")
  createdAt    DateTime @default(now()) @map("created_at")

  connection ProviderConnection @relation(fields: [connectionId], references: [id])
  wallet     ProviderWallet     @relation(fields: [walletId], references: [id])

  @@id([clientId, connectionId, walletId])
  @@map("provider_wallet_connection")
}

model ProviderSync {
  id           String    @id
  clientId     String    @map("client_id")
  connectionId String    @map("connection_id")
  status       String
  errorName    String?   @map("error_name")
  errorMessage String?   @map("error_message")
  errorTraceId String?   @map("error_trace_id")
  createdAt    DateTime  @default(now()) @map("created_at")
  completedAt  DateTime? @map("completed_at")

  connection ProviderConnection @relation(fields: [connectionId], references: [id])

  @@map("provider_sync")
}

model ProviderTransfer {
  id              String   @id
  clientId        String   @map("client_id")
  sourceWalletId  String?  @map("source_wallet_id")
  sourceAccountId String?  @map("source_account_id")
  sourceAddressId String?  @map("source_address_id")
  provider        String
  externalId      String   @map("external_id")
  request         Json
  createdAt       DateTime @default(now()) @map("created_at")

  sourceWallet  ProviderWallet?  @relation("SourceWallet", fields: [sourceWalletId], references: [id])
  sourceAccount ProviderAccount? @relation("SourceAccount", fields: [sourceAccountId], references: [id])
  sourceAddress ProviderAddress? @relation("SourceAddress", fields: [sourceAddressId], references: [id])

  @@map("provider_transfer")
}
